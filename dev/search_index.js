var documenterSearchIndex = {"docs":
[{"location":"functions/","page":"Functions","title":"Functions","text":"This page contains the documentation for various useful  functions in the NMRInversions package.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"tip: Tip\nFrom the Julia command line, you can enter '?',  followed by the name of any function, struct,  or object you want to learn more about (try it!). After typing using NMRInversions in the Julia console,  this feature will work for all the functions mentioned below.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"info: Info\nIn Julia, function definitions look like this:foo(x, y, z ; a, b)For the example above, foo is the name of the function,  and the contents of the parenteses are the arguments.   Within the parenteses, we got two types of arguments:Positional argumentsEverything that appears before the semicolon ;  (x,y and z in this example) is necessary, and must be given in a specific order.Keyword arguments.Everything that appears after the semicolon ;  (b and a in this example) is optional, and can be given in any order, but its name must be specified.In the example above, we can call the function by typing foo(1, 2, 3), (in which case, x=1, y=2, z=3, and the default value for a and b will be used).  You can also call the function by typing foo(1, 2, 3, a=3), to specify the value for a,  or by typing foo(1, 2, 3, b=3, a = 2), to specify the value for both a and b.Sometimes, if there are many keyword arguments, we write  the function as foo(x, y ; kwargs...).  For the necessary arguments before the semicolon, order matters.  For the keyword arguments after the semicolon, order does not matter,  but the name of each argument must be specified. For more information, please refer to this link.","category":"page"},{"location":"functions/#Importing-data","page":"Functions","title":"Importing data","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"This package offers some functions to import NMR experiment data of various formats. Alternatively, you can of course import your data however you see fit. If a format you're working with is not yet supported,  please submit an issue  and we'll work on it.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"The most basic use case would be using data saved in a csv format,  where there are only two columns,  one for your x-axis (time for relaxation and b-factor for diffusion) and one for your y-axis (signal intensity).","category":"page"},{"location":"functions/#NMRInversions.import_csv-Tuple{Type{<:pulse_sequence1D}, String}","page":"Functions","title":"NMRInversions.import_csv","text":"import_csv(seq, file)\n\nImport data from a CSV file. The function reads the file and returns an input1D structure.\n\nseq is the 1D pulse sequence (e.g. IR, CPMG, PFG)\nfile is the path to the CSV file which contains the data (x, y) in two respective columns.\n\nThe function can be called without the seq argument, and the output will be the x and y vectors  (use it like, x,y =import_csv()). Alternatively, the function can also be called with only the seq argument, in which case a file dialog will open to select the file (use it like, data = import_csv(IR))\n\nPlease note that this function will just import the data as is, without any unit conversions. Ensure that your x-axis is in SI.\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Functions","title":"Functions","text":"If you're using a spinsolve instrument, you can use the import_spinsolve function. This one requires two files as an input.  The aqcu.par is automatically exported by SpinsolveExpert,  but you might have to export your data file manually in a csv format.","category":"page"},{"location":"functions/#NMRInversions.import_spinsolve-Tuple{String}","page":"Functions","title":"NMRInversions.import_spinsolve","text":"import_spinsolve(files)\n\nImport data from a Spinsolve experiment.  Two paths must be provided as follows (order is not important):\n\nfiles = [.../datafile.csv , .../acqu.par] \n\nCalling this function without an argument by typing import_spinsolve() will open a file dialog to select the files. The function reads the acqu.par.bak file to get the acquisition parameters, and the .dat file to get the data.  The function returns an input2D structure.\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Functions","title":"Functions","text":"For geospec instruments, you can export your raw data as a text file. That text file can be read by the import_geospec function.","category":"page"},{"location":"functions/#NMRInversions.import_geospec-Tuple{String}","page":"Functions","title":"NMRInversions.import_geospec","text":"import_geospec(dir)\n\nImport data from a .txt format, as exported by Geospec instruments.\n\nThe function reads the relevant information, performs a phase correction on the data, and returns an input1D or input2D structure.\n\nCalling this function without an argument by typing import_geospec()  will open a file dialog to select the .txt file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Inversion","page":"Functions","title":"Inversion","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"The most important function is invert(), which is the main function of the package. It works as follows:","category":"page"},{"location":"functions/#NMRInversions.invert-Tuple{Type{<:pulse_sequence1D}, AbstractArray, Vector}","page":"Functions","title":"NMRInversions.invert","text":"Inversion for 1D pulse sequences:\n\ninvert(seq, x, y ; lims, alpha, solver, normalize)\n\nThis function will build a kernel and use it to perform an inversion using the algorithm of your choice. The output is an inv_out_1D structure.\n\nNecessary (positional) arguments:\n\nseq is the 1D pulse sequence (e.g. IR, CPMG, PFG)\nx is the experiment x axis (time or b factor etc.)\ny is the experiment y axis (intensity of the NMR signal)\n\nOptional (keyword) arguments:\n\nlims=(a,b,c) will set the \"limits\" of the output X, \n\nso that it starts from 10^a, ends in 10^b and consists of c  logarithmically spaced values  (default is (-5, 1, 128) for relaxation and (-10, -7, 128) for diffusion).  Alternatively, a vector of values can be used directly, if more freedom is needed  (e.g. lims=exp10.(range(-4, 1, 128))).\n\nalpha determines the smoothing term. Use a real number for a fixed alpha.  \n\nNo selection will lead to automatically determining alpha through the  default method, which is gcv().\n\nsolver is the algorithm used to do the inversion math. Default is brd.\nnormalize will normalize y to 1 at the max value of y. Default is true.  \n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.invert-Tuple{input1D}","page":"Functions","title":"NMRInversions.invert","text":"invert(data::input1D ; kwargs...)\n\nInstead of the positional arguments seq, x and y, you can use a single input1D structure, which contains the same information.  Especially useful if you're using the output of one  of the import functions (look documentation tutorial section).\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Functions","title":"Functions","text":"Due to Julia's multiple dispatch,  it is possible to define a function with the same name but different arguments, to achieve different results.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Because of that, the inversion function also works for 2D inversions, if the following arguments are used instead:","category":"page"},{"location":"functions/#NMRInversions.invert-Tuple{Type{<:pulse_sequence2D}, AbstractVector, AbstractVector, AbstractMatrix}","page":"Functions","title":"NMRInversions.invert","text":"Inversion for 2D pulse sequences:\n\ninvert(seq, x_direct, x_indirect, Data; lims1, lims2, alpha, solver, normalize)\n\nThis function will build a kernel and use it to perform an inversion using the algorithm of your choice. The output is an inv_out_2D structure.\n\nNecessary (positional) arguments:\n\nseq is the 2D pulse sequence (e.g. IRCPMG)\nx_direct is the direct dimension acquisition parameter (e.g. the times when you aquire CPMG echoes).\nx_indirect is the indirect dimension acquisition parameter (e.g. all the delay times τ in your IR sequence).\nData is the 2D data matrix of complex data.\n\nOptional (keyword) arguments:\n\nlims1 determines the output \"range\" of the inversion in the direct dimension (e.g. T₂ times in IRCPMG)\nlims2 determines the output \"range\" of the inversion in the indirect dimension (e.g. T₁ times in IRCPMG)\n\nIn both cases above, you can use a tuple specifying the limits of the range, or a vector of values, same as the lims argument in the 1D inversion.\n\nalpha determines the smoothing term. Use a real number for a fixed alpha.  No selection will lead to automatically determining alpha through the default method, which is gcv.\nsolver is the algorithm used to do the inversion math. Default is brd.\nnormalize will normalize Data to 1 at the max value of Data. Default is true.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.invert-Tuple{input2D}","page":"Functions","title":"NMRInversions.invert","text":"invert(data::input2D ; kwargs...)\n\nInstead of the positional arguments seq, x_direct , x_indirect and Data, you can use a single input2D  structure, which contains the same information.  Especially useful if you're using the output of one of the  import functions (look documentation tutorial section).\n\n\n\n\n\n","category":"method"},{"location":"functions/#Finding-alpha","page":"Functions","title":"Finding alpha","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Here we provide two options for finding the optimal value for alpha,  namely Generalized Cross Validation (GCV) or L-curve.  Generally gcv seems slightly more reliable in NMR, but it's far from  perfect, so it's good to have alternatives and cross-check. The following methods can be used as inputs for the alpha argument in the invert function:","category":"page"},{"location":"functions/#NMRInversions.gcv-Tuple{}","page":"Functions","title":"NMRInversions.gcv","text":"gcv()\n\nConstructor for the gcv method described in Mitchell 2012. No arguments required.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.gcv-Tuple{Real}","page":"Functions","title":"NMRInversions.gcv","text":"gcv(start; kwargs...)\n\nConstructor for finding the optimal alpha value via gcv score box optimization, given a starting value.\n\nNecessary (positional) arguments:\n\nstart is the starting alpha value. \n\nChoose something sensible, usually a value between 0.1 and 10 would work well.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is LBFGS(). Only first order optimizers can be chosen here.  For more details, refer to Optim.jl documentation.\n\nopts an Optim.Options() structure which can provide some preferences to the solver.\n\nPlease have a look here.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.gcv-Tuple{Real, Real}","page":"Functions","title":"NMRInversions.gcv","text":"gcv(lower, upper ; kwargs...)\n\nConstructor for finding the optimal alpha value via gcv score univariate optimization, given some lower and upper bounds.\n\nNecessary (positional) arguments:\n\nlower is the lower bound, or lowest alpha value the algorighm will consider.\nupper is the upper bound, or highest alpha value the algorighm will consider.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is Brent() and the only alternative is GoldenSection(), which is normally slower.\n\nabs_tol determines what's the smallest change in alpha the algorithm should care about.\n\nDefault is 1e-3.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.lcurve-Tuple{Real, Real, Int64}","page":"Functions","title":"NMRInversions.lcurve","text":"lcurve(lowest_value, highest_value, number_of_steps)\n\nConstructor for testing all L-curve curvatures between some bounds and  picking the optimal.\n\nlowest_value is the lowest alpha value.\nhighest_value is the highest alpha value.\nnumber_of_steps is the number of alpha values that will be tested.\n\nThis is a very crude and rather slow method, mostly for demonstration purposes.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.lcurve-Tuple{Real}","page":"Functions","title":"NMRInversions.lcurve","text":"lcurve(start; kwargs...)\n\nConstructor for finding the optimal alpha value via lcurve curvature box optimization, given a starting value.\n\nNecessary (positional) arguments:\n\nstart is the starting alpha value. \n\nChoose something sensible, usually a value between 0.1 and 10 would work well.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is LBFGS(). Only first order optimizers can be chosen here.  For more details, refer to Optim.jl documentation.\n\nopts an Optim.Options() structure which can provide some preferences to the solver.\n\nPlease have a look here.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.lcurve-Tuple{Real, Real}","page":"Functions","title":"NMRInversions.lcurve","text":"lcurve(lower, upper ; kwargs...)\n\nConstructor for finding the optimal alpha value via lcurve curvature univariate optimization, given some lower and upper bounds.\n\nNecessary (positional) arguments:\n\nlower is the lower bound, or lowest alpha value the algorighm will consider.\nupper is the upper bound, or highest alpha value the algorighm will consider.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is Brent() and the only alternative is GoldenSection(), which is normally slower.\n\nabs_tol determines what's the smallest change in alpha the algorithm should care about.\n\nDefault is 1e-3.\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Functions","title":"Functions","text":"The gcv() method [2] usually involves the least amount of  function calls and it is thus much faster, thus used as the default option. If you want more precision, the univariate or box methods should be used instead. Note that gcv() will NOT work for pdhgm() solver, so you'll have to choose  an alternative explicitly when using that solver.","category":"page"},{"location":"functions/#Exponential-fits","page":"Functions","title":"Exponential fits","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"For 1D data, we can use the expfit function to perform multiexponential fits. We can use the function by specifying either the number of exponential components, or a vector which defines the starting points for the regression. See below:","category":"page"},{"location":"functions/#NMRInversions.expfit-Tuple{Union{Int64, Vector{<:Real}}, Type{<:pulse_sequence1D}, Vector, Vector}","page":"Functions","title":"NMRInversions.expfit","text":"expfit(n, seq, x, y; kwargs...)\n\nFit an n-exponential function to the data x and y. \n\nThe outut is an expfit_struct structure.\n\nArguments:\n\nn : Integer specifying the number of exponential terms.\nseq : pulse sequence.\nx : acquisition x parameter (time for relaxation or b-factor for diffusion).\ny : acquisition y parameter (magnetization).\n\nOptional arguments:\n\nsolver : Optim solver, default choice is IPNewton().\nnormalize : Normalize the data before fitting? (default is true).\nL : An integer specifying which norm of the residuals you want to minimize (default is 2).\n\nThe n argument can also be a vector of initial parameter guesses,  in which case it also determines the number of exponential terms used. It should be of the form [a1, b1, a2, b2, ...],  where a's are the amplitudes and b's are the parameters inside the exponentials.\n\nThe length of the vector in this case must be an even number.\n\nThe following examples might help to clarify: \n\nexpfit([a,b] , CPMG, x, y) -> mono-exponential fit with initial guess: a * exp.( (1/b) * x) \n\nexpfit([a,b,c,d] , CPMG, x, y) -> bi-exponential fit with initial guess: a * exp.( (1/b) * x) + c * exp.((1/d) * x) \n\nexpfit([a,b,c,d,e,f] , CPMG, x, y) -> tri-exponential fit with initial guess: a * exp.( (1/b) * x) + c * exp.((1/d) * x) + e * exp.((1/f) * x) \n\n(where a,b,c,d,e,f are numbers of your choice)\n\nNumbers of parameters beyond tri-exponential can also be used, but it is not recommended.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.expfit-Tuple{Union{Int64, Vector{<:Real}}, input1D}","page":"Functions","title":"NMRInversions.expfit","text":"expfit(n, data; kwargs...)\n\nSimilar to the invert function, expfit can be called using an input1D structure.\n\nArguments:\n\nn : Integer specifying the number of exponential terms.\ndata : input1D structure containing the data to be fitted.\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Functions","title":"Functions","text":"If you have some rough clue about what results you expect,  it's best to define some starting points close to these. (especially important if you're using double or tri-exponential fits.)","category":"page"},{"location":"functions/#Plotting","page":"Functions","title":"Plotting","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"This package offers plotting capabilities, using its GLMakie extension. Simply use using GLMakie before or after using NMRInversions to load the package, and these functions become available.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"We basically take the plot() function offered by GLMakie and extend it to types from the package.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"For inversions results, if your inv_out_1D or inv_out_2D struct is saved as a variable named r, using plot(r) will run a GUI to interractively visualize your data and select regions to characterize.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Using a matrix or vector of results (e.g. plot([r1, r2, r3]) will plot all of them on the same figure, but without the selection options.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"For example, for 1D inversions, we have:","category":"page"},{"location":"functions/#MakieCore.plot-Tuple{inv_out_1D}","page":"Functions","title":"MakieCore.plot","text":"plot(res::inv_out_1D)\n\nRun the GUI to plot the 1D inversion results and select peaks you want to label.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MakieCore.plot-Tuple{VecOrMat{inv_out_1D}}","page":"Functions","title":"MakieCore.plot","text":"plot(res_mat::VecOrMat{inv_out_1D};kwargs...)\n\nPlot the results contained in a vector of inv_out_1D structures.\n\nThe keyword (optional) arguments are:\n\nselections : Whether to highlight the selections in the plots (default is false).\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Functions","title":"Functions","text":"And for 2D inversions:","category":"page"},{"location":"functions/#MakieCore.plot-Tuple{inv_out_2D}","page":"Functions","title":"MakieCore.plot","text":"Makie.plot(res::inv_out_2D)\n\nRun the GUI to plot the results and select peaks you want to label.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MakieCore.plot-Tuple{AbstractVecOrMat{inv_out_2D}}","page":"Functions","title":"MakieCore.plot","text":"plot(results::AbstractVecOrMat{inv_out_2D}; kwargs...)\n\nPlot the results contained in a matrix of inv_out_2D structures. The arrangement is determined by the shape of the matrix.\n\nThe arguments are:\n\nresults : The inv_out_2D matrix or vector containing the fit results.\n\nKeyword (optional) arguments:\n\ndims : Dimensions of each plot (default: (400, 400)).\ntitle : Title of the plot (default is the title in the invout2D).\ncolormap : Color map of the plot (default: :viridis).\ncontf : Whether to use a filled contour plot (default: false).\nlevels : Number of contour levels (default: 40).\nlabelsizes : Size of the axis labels (default: (23, 23)).\nticksizes : Size of the axis ticks (default: (14, 14)).\ntitlesize : Size of the title (default: 17).\ntitlefont : Font of the title (default: :bold).\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Functions","title":"Functions","text":"For expfits, we have:","category":"page"},{"location":"functions/#MakieCore.plot-Tuple{expfit_struct}","page":"Functions","title":"MakieCore.plot","text":"plot(res::expfit_struct...; kwargs...)\n\nPlot the results of an expfit call. \n\nThis function can take any number of expfit_struct structures as input. \n\ne.g. plot(data1) plots the data and the corresponding fit, but plot(data1, data2) or plot(data1, data2, data3) work as well, and they plot all of the results on the same plot.\n\nKeyword (optional) arguments:\n\nmarkersize : The size of the markers (default is 7).\nnormeq : Whether to plot the normalised form of the equation or not (default is true).\nyscale : The scale of the y-axis (default is identity).\n\n\n\n\n\n","category":"method"},{"location":"functions/#MakieCore.plot!-Tuple{Union{GridPosition, Figure}, expfit_struct}","page":"Functions","title":"MakieCore.plot!","text":"plot!(fig, res...; names, markersize, normeq)\n\nPlots the results of an expfit call on a figure or a grid position object.\n\nThe arguments are:\n\nfig : The figure or grid position object.\nres : One or more expfit_struct structures containing the fit results.\n\nKeyword (optional) arguments:\n\nmarkersize : The size of the markers (default is 7).\nnormeq : Whether to plot the normalised form of the equation or not (default is true).\nyscale : The scale of the y-axis (default is identity).\n\nNote that the res inputs are not a vector, but individual expfit_struct structures, like: plot!(fig, data1, data2, data3). If you want to use a vector of expfit_struct structures, make sure to  splat it by using ... in the function call (e.g. plot!(fig, [data1, data2, data3]...)).\n\n\n\n\n\n","category":"method"},{"location":"functions/#Miscellaneous","page":"Functions","title":"Miscellaneous","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Once you have selected some peaks in your inversion results through the GUI, you might want to extract the weighted averages of these selected peaks, to get the underlying relaxation times or diffusion coefficients. The following functions do the job:","category":"page"},{"location":"functions/#NMRInversions.weighted_averages-Tuple{inv_out_1D}","page":"Functions","title":"NMRInversions.weighted_averages","text":"weighted_averages(r::inv_out_1D)\n\nReturn a vector with the weighted averages for  the selections in the input structure, and a  vector with the respective area fractions of  these selections.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.weighted_averages-Tuple{inv_out_2D}","page":"Functions","title":"NMRInversions.weighted_averages","text":"weighted_averages(r::inv_out_2D)\n\nReturn two vectors with the weighted averages  for the selections in the input structure, one for each dimension, as well as a vector with the volume fractions of these selections.\n\n\n\n\n\n","category":"method"},{"location":"references/","page":"References","title":"References","text":"P. C. Hansen. Discrete inverse problems: Insight and algorithms (Society for Industrial and Applied Mathematics, 2010).\n\n\n\nJ. Mitchell, T. Chandrasekera and L. Gladden. Numerical estimation of relaxation and diffusion distributions in two dimensions. Progress in nuclear magnetic resonance spectroscopy 62, 34–50 (2012).\n\n\n\nY.-Q. Song, L. Venkataramanan, M. Hürlimann, M. Flaum, P. Frulla and C. Straley. T1–T2 Correlation Spectra Obtained Using a Fast Two-Dimensional Laplace Inversion. Journal of Magnetic Resonance 154, 261–268 (2002).\n\n\n\nL. Venkataramanan, Y.-Q. Song and M. Hurlimann. Solving Fredholm integrals of the first kind with tensor product structure in 2 and 2.5 dimensions. IEEE Transactions on Signal Processing 50, 1017–1026 (2002).\n\n\n\nN. Bloembergen, E. M. Purcell and R. V. Pound. Relaxation Effects in Nuclear Magnetic Resonance Absorption. Phys. Rev. 73, 679–712 (1948).\n\n\n\nT. C. Chandrasekera and J. Mitchell. Numerical inversion methods for recovering negative amplitudes in two-dimensional nuclear magnetic resonance relaxation-time correlations. Phys. Rev. E 98, 043308 (2018).\n\n\n\nA. Reci, A. Sederman and L. Gladden. Obtaining sparse distributions in 2D inverse problems. Journal of Magnetic Resonance 281, 188–198 (2017).\n\n\n\n","category":"page"},{"location":"savefiles/","page":"Saving data","title":"Saving data","text":"Julia provides the Serialization.jl package to save and load data in a binary format. This provides us with a straightforward way to save our results in a file, and load them later if we need to check what's inside them.","category":"page"},{"location":"savefiles/","page":"Saving data","title":"Saving data","text":"info: Info\nSerialization.jl is part of the standard library, and thus it can be used without installation.","category":"page"},{"location":"savefiles/#Saving-results","page":"Saving data","title":"Saving results","text":"","category":"section"},{"location":"savefiles/","page":"Saving data","title":"Saving data","text":"Assuming that we have a variable results which contains our data, (e.g., results is a inv_out_2D structure), we can use the following example to save them in a file.","category":"page"},{"location":"savefiles/","page":"Saving data","title":"Saving data","text":"using Serialization\n\n# Save the results in a file named \"results.dat\"\n# using the serialize function\nserialize(\"results.dat\", results)\n\n# Load the results\n# using the deserialize function\nresults = deserialize(\"results.dat\")\n","category":"page"},{"location":"savefiles/","page":"Saving data","title":"Saving data","text":"Note that we use a .dat extension above, but you can use whatever  extension you like, as long as it makes sense to you.","category":"page"},{"location":"savefiles/#Saving-plots","page":"Saving data","title":"Saving plots","text":"","category":"section"},{"location":"savefiles/","page":"Saving data","title":"Saving data","text":"You can use the 'save' function provided by GLMakie to save plots.","category":"page"},{"location":"savefiles/","page":"Saving data","title":"Saving data","text":"using NMRInversions, GLMakie\n\ndata = import_csv(IR)\nresults = invert(data)\np = plot(results)\n\nsave(\"results.png\", p)\n","category":"page"},{"location":"savefiles/","page":"Saving data","title":"Saving data","text":"This will save the plot p in the file path results.png.","category":"page"},{"location":"savefiles/","page":"Saving data","title":"Saving data","text":"If you'd rather use a file dialog to specify the path interactively, you can do something like:","category":"page"},{"location":"savefiles/","page":"Saving data","title":"Saving data","text":"save(NMRInversions.save_file(\"\", filterlist = \"png\") , p)\n","category":"page"},{"location":"savefiles/","page":"Saving data","title":"Saving data","text":"This will open a file dialog, where you can interractively select where to save the image.","category":"page"},{"location":"savefiles/","page":"Saving data","title":"Saving data","text":"Note that for 2D data, the plot GUI already has a \"Save and exit\" button which  can be used to save the plot in the same way.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"What follows is a rough explanation of what this package is about. If you're looking for more rigor, please refer to sources  [1–4] in the  References section. If you believe something mentioned below is wrong or misleading, please submit an issue.","category":"page"},{"location":"theory/#Exponentials-in-NMR","page":"Theory","title":"Exponentials in NMR","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"For NMR relaxation and diffusion experiments in liquids, we expect the results we get to look more or less like an exponential decay  or recovery, as described by the BPP theory [5].","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"To obtain useful information from NMR experiments, we can use different  exponential forms, according to the pulse sequence used.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Examples are : ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Pulse sequence Equation\nInversion recovery M = 1 - 2( exp(-tT_1) )\nSaturation recovery M = 1 - exp(-tT_1)\nCPMG M = exp(-tT_2)\nPGSE M = exp(-b * D)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":", where M is the magnetization (the \"signal\" you would record in such an  experiment, normalized so that its maximum value is 1), t is time, T_1  and T_2 are relaxation time constants, b is the b-factor in the  Stejskal-Tanner equations, and D is diffusion coefficient.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This is all good if the sample you want to study is nice and simple  (e.g., a liquid made up of a single type of molecule), and you can fit your   data using the equations above to obtain the desired quantity, which would be  either T_1, T_2, or D. ","category":"page"},{"location":"theory/#Multi-exponential-forms","page":"Theory","title":"Multi-exponential forms","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"If the NMR data comes from a system which is to some degree inhomogenous, e.g. has multiple pore environments, several different liquids, etc.,  we would expect for the data to be a sum of exponentials, one for each of the underlying components.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For example, if we do a CPMG experiment on a mixture of water and ethanol, we would expect the equation to look like :","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"M = alpha exp(-tT_2 water) + beta exp(-tT_2 ethanol)  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where alpha and beta would represent the fractions of  water and ethanol spins into the system, respectively.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Of course, there's no reason to stop at two components. The more general form could be written as :","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"M = sum_k=1^n f_k exp(-tT_2k)  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where n is the total number of different components hidden behind the data, and f_k is the fraction of the kth component.","category":"page"},{"location":"theory/#Exponential-fits","page":"Theory","title":"Exponential fits","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Normally, we would use some type of nonlinear regression to handle cases where we already know that the system we  study is made up of a limited number of components  (n would be 1,2 or maybe 3).  This package covers this case using the expfit(n, data) function.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"However, in a lot of realistic scenarios, this method fails for a few reasons:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We don't always know exactly how many components our system is made out of.\nThere might be a virtually continuous range of relaxation times (or diffusion  coefficients) within the system, e.g. a fluid within a rock sample with  many different pore sizes might have a different relaxation time for each pore size.\nWhen we add too many degrees of freedom by introducing lots of free  variables in the fit equation, it's easy for the algorithm to converge in nonsensical values which just happen to be close to the starting points  and yield a low-enough value for the cost function. The fit could be satisfying, but the values might be unrealistic and unreliable.","category":"page"},{"location":"theory/#Inversions","page":"Theory","title":"Inversions","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"In linear algebra terms, a discrete version of the equation :","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"M = sum_k=1^n f_k exp(-tT_2k)   ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"can be written as :","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Kf = g  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where :","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"g is a vector containing the M values recorded from an experiment,\nf is a vector containing the f_k values present in the system,\nK is a \"kernel\" matrix, which can be constructed for a predetermined, usually logarithmically-spaced range of T_2 values.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"What we are interested in is to solve for the f vector, since  g is already known and K can be constructed according to the range of  T_2 values we're looking for (or T_1, or D).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The \"naive\" way to approach this would be to use the inverse of the K matrix, and  solve the problem as ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"f = K^-1g  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"However the resulting f would be terrible for a few reasons:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Even small amounts of noise in the data would mess up the results due to the very large  condition number of the K matrix. \nSince there will be some amount of noise in g, we would not even want our fit  curve (Kf) to be exactly equal to the data (g), since that would involve fiting  the noise.\nNegative values in f would be okay with this method, which does not make much  sense since we can't have negative amounts of relaxation times  (unless you have a reason to allow that [6]).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This is a textbook example of an inverse problem.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The most commmon way to approach it would be Tikhonov regularization, where we solve the following optimization problem : ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"min_f geq 0  Kf-g_2^2 + alpha f_2^2  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where alpha is a scalar value referred to as the \"regularization parameter\".","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This way, we minimize the residuals (Kf-g) while preventing the norm of the   solution (f) from getting out of control due to the noise in g.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Low values of alpha would result in noisy, unregularized solutions with spikey T or D distributions, while large alpha's would lead to very broad, over- smoothed distributions.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The invert function in this package solves this problem, and automatically finds the  optimal value for alpha using the GCV method. There is also an option to use the  L-curve method to find alpha, or supply a constant value for it.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you would like to contribute to the package, you may start with one of  the existing issues. Please feel free to create a pull request if you'd like to implement a feature. Stanard Julia style  is recommended, and writing tests for any new (or existing) features would be nice.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you're unsure about anything or need further guidance, feel free to start a discussion.","category":"page"},{"location":"installation/#Installing-Julia","page":"Installation","title":"Installing Julia","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can download the Julia programming language by following this link. Afterwards, you can either use the Julia console (aka REPL)  by finding the Julia .exe file in your computer, or you can use VScode, which provides an environment similar to MATLAB with the use of the  Julia extension (follow link for installation instructions).  Of course, if you already have a preferred development workflow  and you know what you're doing, by all means go for it.","category":"page"},{"location":"installation/#Installing-the-package","page":"Installation","title":"Installing the package","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"The package can be installed by running the following command on the Julia console:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg ; Pkg.add(\"NMRInversions\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"This usually takes a while, but it needs to be done only once  (unless you swap environment, more on that  here).","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Afterwards, you can use the package by running ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using NMRInversions","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"in your Julia console, every time you start a new session.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Whenever a new version comes up, you can run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg ; Pkg.update(\"NMRInversions\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"to update the package.","category":"page"},{"location":"installation/#GLMakie-extension","page":"Installation","title":"GLMakie extension","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"The package provides an extension for interactive visualization, using the GLMakie package. To gain access to these capabilities, you also need to install GLMakie:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg ; Pkg.add(\"GLMakie\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"And to use it, you need to run","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using GLMakie","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"in order to access the plotting functions.","category":"page"},{"location":"types_structs/","page":"Types and Structures","title":"Types and Structures","text":"In order to take advantage of Julia's multiple dispatch,  we need to define some structures which can be used as input to our functions.","category":"page"},{"location":"types_structs/","page":"Types and Structures","title":"Types and Structures","text":"info: Info\nStructures are object which may contain multiple fields. The fields can be accessed using the dot syntax. For example, if we have a structure named foo, with two fields, a, and b,  we can access the value of a using foo.a and the value of b using foo.b.","category":"page"},{"location":"types_structs/#Pulse-sequences","page":"Types and Structures","title":"Pulse sequences","text":"","category":"section"},{"location":"types_structs/","page":"Types and Structures","title":"Types and Structures","text":"The following types are used so that the invert function  can create the appropriate kernel for the inversion.  Anywhere you see the seq keyword, one of the following must be used.","category":"page"},{"location":"types_structs/#NMRInversions.IR","page":"Types and Structures","title":"NMRInversions.IR","text":"Inversion recovery pulse sequence for 1D relaxation experiments. It can be used wherever the seq argument is required. \n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.SR","page":"Types and Structures","title":"NMRInversions.SR","text":"Saturation recovery pulse sequence for 1D relaxation experiments. It can be used wherever the seq argument is required. \n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.CPMG","page":"Types and Structures","title":"NMRInversions.CPMG","text":"CPMG pulse sequence for 1D relaxation experiments. It can be used wherever the seq argument is required. \n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.PFG","page":"Types and Structures","title":"NMRInversions.PFG","text":"Pulsed field gradient pulse sequence for 1D diffusion experiments. It can be used wherever the seq argument is required. \n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.IRCPMG","page":"Types and Structures","title":"NMRInversions.IRCPMG","text":"Inversion recovery - CPMG pulse sequence for 2D relaxation experiments (T1-T2). The direct dimension is the T2, and the indirect dimension is the T1 acquisition times. It can be used wherever the seq argument is required.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#Inversion-solvers","page":"Types and Structures","title":"Inversion solvers","text":"","category":"section"},{"location":"types_structs/","page":"Types and Structures","title":"Types and Structures","text":"These are used to let the invert fucntion know which solver to use. They can be used as input to the invert function as the 'solver' argument. (e.g., invert(data, solver=brd) [3] or  invert(data, solver=pdhgm(10,0.1) )) [7].","category":"page"},{"location":"types_structs/#NMRInversions.brd","page":"Types and Structures","title":"NMRInversions.brd","text":"brd\n\nSolver for tikhonov (L2) regularization, following this paper [4]. Very fast, but only uses the identity as tiknohonov matrix. It can be used as a \"solver\" for the invert function.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.pdhgm","page":"Types and Structures","title":"NMRInversions.pdhgm","text":"pdhgm(σ, τ)\n\nPrimal dual hybrid gradient method for L1 regularization,  following this paper [7] It can be used as a \"solver\" for the invert function.\n\nThe particular choice of σ and τ is heuristic.  A smaller σ will increase the stability while reducing the convergence speed of the algorithm. A good compromise between the two was found when σ = 0.1 and τ = 10.  The best values of σ and τ will depend slightly on the scaling of the signal.  Therefore, it is best to normalize the NMR signal to a maximum of 1, a technique which was followed in the cited study.\n\nNote that for this method, the role of α is inverted, with larger α values leading to less smoothing, not more. For that reason, alpha=gcv() (Mitchell method) will not work. Please use alpha=gcv(starting_value) or `alpha=gcv(lowerlimit, upperlimit)', or some lcurve method instead.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.optim_nnls","page":"Types and Structures","title":"NMRInversions.optim_nnls","text":"optim_nnls(order)\n\nSimple non-negative least squares method for regularization,  implemented using Optim.jl. All around effective, but can be slow for large problems, such as 2D inversions. It can be used as a \"solver\" for invert function.\n\norder is an integer that determines the tikhonov matrix  (for more info look Hansen's 2010 book on inverse problems).  Order n means that the penalty term will be the n'th derivative of the results. \n\nL detemines which norm of the penalty term will be minimized.  Default is 2 (tikhonov regularization).\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#Finding-optimal-alpha","page":"Types and Structures","title":"Finding optimal alpha","text":"","category":"section"},{"location":"types_structs/","page":"Types and Structures","title":"Types and Structures","text":"These are methods for finding the optimal regularization parameter.  They can be used as input to the invert function as the 'alpha' argument (e.g., invert(data, alpha=gcv) or invert(data, alpha=lcurve(0.001,1,64)) ). If you'd like to use a particular value of alpha,  you can just use that number instead (invert(data, alpha=1)).","category":"page"},{"location":"types_structs/#NMRInversions.gcv","page":"Types and Structures","title":"NMRInversions.gcv","text":"gcv()\n\nConstructor for the gcv method described in Mitchell 2012. No arguments required.\n\n\n\n\n\ngcv(start; kwargs...)\n\nConstructor for finding the optimal alpha value via gcv score box optimization, given a starting value.\n\nNecessary (positional) arguments:\n\nstart is the starting alpha value. \n\nChoose something sensible, usually a value between 0.1 and 10 would work well.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is LBFGS(). Only first order optimizers can be chosen here.  For more details, refer to Optim.jl documentation.\n\nopts an Optim.Options() structure which can provide some preferences to the solver.\n\nPlease have a look here.\n\n\n\n\n\ngcv(lower, upper ; kwargs...)\n\nConstructor for finding the optimal alpha value via gcv score univariate optimization, given some lower and upper bounds.\n\nNecessary (positional) arguments:\n\nlower is the lower bound, or lowest alpha value the algorighm will consider.\nupper is the upper bound, or highest alpha value the algorighm will consider.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is Brent() and the only alternative is GoldenSection(), which is normally slower.\n\nabs_tol determines what's the smallest change in alpha the algorithm should care about.\n\nDefault is 1e-3.\n\n\n\n\n\n","category":"function"},{"location":"types_structs/#NMRInversions.lcurve","page":"Types and Structures","title":"NMRInversions.lcurve","text":"lcurve(lowest_value, highest_value, number_of_steps)\n\nConstructor for testing all L-curve curvatures between some bounds and  picking the optimal.\n\nlowest_value is the lowest alpha value.\nhighest_value is the highest alpha value.\nnumber_of_steps is the number of alpha values that will be tested.\n\nThis is a very crude and rather slow method, mostly for demonstration purposes.\n\n\n\n\n\nlcurve(start; kwargs...)\n\nConstructor for finding the optimal alpha value via lcurve curvature box optimization, given a starting value.\n\nNecessary (positional) arguments:\n\nstart is the starting alpha value. \n\nChoose something sensible, usually a value between 0.1 and 10 would work well.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is LBFGS(). Only first order optimizers can be chosen here.  For more details, refer to Optim.jl documentation.\n\nopts an Optim.Options() structure which can provide some preferences to the solver.\n\nPlease have a look here.\n\n\n\n\n\nlcurve(lower, upper ; kwargs...)\n\nConstructor for finding the optimal alpha value via lcurve curvature univariate optimization, given some lower and upper bounds.\n\nNecessary (positional) arguments:\n\nlower is the lower bound, or lowest alpha value the algorighm will consider.\nupper is the upper bound, or highest alpha value the algorighm will consider.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is Brent() and the only alternative is GoldenSection(), which is normally slower.\n\nabs_tol determines what's the smallest change in alpha the algorithm should care about.\n\nDefault is 1e-3.\n\n\n\n\n\n","category":"function"},{"location":"types_structs/#Inversion-and-expfit-inputs","page":"Types and Structures","title":"Inversion and expfit inputs","text":"","category":"section"},{"location":"types_structs/","page":"Types and Structures","title":"Types and Structures","text":"These can be used as inputs containing all of the necessary information to run the inversion and expfit functions  (e.g. if a is an input1D object, invert(a) does the job).","category":"page"},{"location":"types_structs/#NMRInversions.input1D","page":"Types and Structures","title":"NMRInversions.input1D","text":"input1D(seq, x, y)\n\nA structure containing the following fields:\n\nseq is the 1D pulse sequence (e.g. IR, CPMG, PFG)\nx, the x values of the measurement (e.g time for relaxation or b-factor for diffusion).\ny, the y values of the measurement. \n\nIt can be used as an input for the invert and expfit functions.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.input2D","page":"Types and Structures","title":"NMRInversions.input2D","text":"input2D(seq, x, y)\n\nA structure containing the following fields:\n\nseq is the 2D pulse sequence (e.g. IRCPMG)\nx_direct is the direct dimension acquisition parameter (e.g. the times when you aquire CPMG echoes).\nx_indirect is the indirect dimension acquisition parameter (e.g. all the delay times τ in your IR sequence).\ndata is the 2D data matrix.\n\nIt can be used as an input for the invert function.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#Inversion-and-expfit-outputs","page":"Types and Structures","title":"Inversion and expfit outputs","text":"","category":"section"},{"location":"types_structs/","page":"Types and Structures","title":"Types and Structures","text":"When you run an inversion function (e.g. r = invert(a)), the output is an inv_out_1D or inv_out_2D structure.","category":"page"},{"location":"types_structs/#NMRInversions.inv_out_1D","page":"Types and Structures","title":"NMRInversions.inv_out_1D","text":"inv_out_1D(seq, x, y, xfit, yfit, X, f, r, SNR, α, selections, filter, title)\n\nOutput of the invert function for 1D pulse sequences. A structure containing the following fields:\n\nseq is the 1D pulse sequence (e.g. IR, CPMG, PFG)\nx, the x values of the measurement (e.g time for relaxation or b-factor for diffusion).\ny, the y values of the measurement.\nxfit, the x values of the fitted data.\nyfit, the y values of the fitted data.\nX, the x values of the inversion results.\nf, the inversion results.\nr, the residuals.\nSNR, the signal-to-noise ratio.\nα, the regularization parameter.\nselections, a vector of tuples whose elements indicate the first and last index of the selected peaks.\nfilter, a vector representing the mask used to filter and scale the data.\ntitle, a title describing the data.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.inv_out_2D","page":"Types and Structures","title":"NMRInversions.inv_out_2D","text":"inv_out_2D(seq, X_dir, X_indir, F, r, SNR, α, filter, selections)\n\nOutput of the invert function for 2D pulse sequences. A structure containing the following fields:\n\nseq is the 2D pulse sequence (e.g. IRCPMG)\nX_dir, the x values of the direct dimension.\nX_indir, the x values of the indirect dimension.\nF, the inversion results as a matrix.\nr, the residuals.\nSNR, the signal-to-noise ratio.\nalpha, the regularization parameter.\nfilter, apply a mask to filter out artefacts when plotting.\nselections, the selection masks (e.g. when you want to highlight some peaks in a T₁-T₂ map).\ntitle, a title describing the data.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.expfit_struct","page":"Types and Structures","title":"NMRInversions.expfit_struct","text":"Output of the expfit function. Structure containing information about multiexponential fits.\n\nThe fields are as follows:\n\nseq: The pulse sequence\nx : The x acquisition values (e.g. time for relaxation or b-factor for diffusion).\ny : The y acquisition values.\nxfit : An array with fitted x values (for plotting purposes).\nyfit : An array with fitted y values (for plotting purposes).\nu : The fitted parameters for the mexp function.\nu0 : The initial parameters for the mexp function.\nr : The residuals.\neq : The equation of the fitted function.\neqn : The equation of the initial function.\ntitle : A title describing the data.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#Kernel-structure","page":"Types and Structures","title":"Kernel structure","text":"","category":"section"},{"location":"types_structs/#NMRInversions.svd_kernel_struct","page":"Types and Structures","title":"NMRInversions.svd_kernel_struct","text":"svd_kernel_struct(K,g,U,S,V)\n\nA structure containing the following fields:\n\nK, the kernel matrix.\nG, the data vector.\nU, the left singular values matrix.\nS, the singular values vector.\nV, the right singular values matrix.\n\nTo access the fields of a structure, we use the dot notation,  e.g. if the structure is called a and we want to access the kernel contained in there, we type a.K\n\n\n\n\n\n","category":"type"},{"location":"","page":"Overview","title":"Overview","text":"Welcome to NMRInversions.jl!","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The goal is to provide an easy-to-use interface to process NMR  relaxation and diffusion data, completely free/open-source, and fully  written in Julia.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Functionality includes :","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Importing NMR data from various instrument manufacturers.\nPerforming numerical inversions and exponential fits with sensible default settings.\nInteractive visualization of results, through the GLMakie extension.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Who would want to use this package :","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Researchers in chemistry, physics, and materials science who rely on NMR  to study molecular dynamics, diffusion and interactions.  NMRInversions.jl simplifies the process of data analysis, allowing researchers  to focus on their scientific questions rather than the intricacies of data processing.\nProfessionals in various fields such as food science, subsurface applications,  or materials engineering can utilize this package to analyze NMR data for quality  control, product development, and research purposes. \nStudents learning about NMR techniques can benefit from a straightforward tool  that helps them understand data processing and analysis.  Educators can use the package as a teaching aid in courses related to NMR or  inverse problems.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Hopefully this documentation will provide all the information you need to get started.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The Theory section should provide some info on what the package is really about.\nFor more details on how to use it, you can start by refering to the examples in the   tutorial.\nTo understand how things really work, have a look at the  Functions and Types and Structures sections.\nIf you have any problems or questions, please feel free to  submit an issue.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page will give you a basic idea about how to use the NMRInversions package. For more details, it's best to refer to the functions page.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hint: Hint\nAll of the commands mentioned below should be typed in the julia console,  or saved in a text file with the .jl extension, to be used  from a terminal with julia file.jl, or through an IDE such as VSCode.","category":"page"},{"location":"tutorial/#Performing-an-inversion","page":"Tutorial","title":"Performing an inversion","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Suppose we're working with data coming from a Spinsolve instrument Then we can do the following:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(you can find some example data in the files of this package,  look at the github page for the example_data folder).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using NMRInversions\n\ndata = import_spinsolve()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Info\nSince we called the import_spinsolve function without an argument,  it'll open a file dialog for us to select the files we want to import. (note that import_spinsolve requires two files, the aqcu.par file containing aqcuistion parameters, plus the .dat or .csv file  containing the experiment data.)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we have the data imported, the inversion can be performed using a single line of code!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"results = invert(data)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Info\nThe results variable above is an inv_out_1D or inv_out_2D structure,  which contains all the relevant information produced by the inversion function. To access that information, we can look at the fields of the structure using the dot notation. The field names contained in the structure can be shown by using the REPL help mode  (typing ? at the julia> prompt), and typing the variable's name (in this case, ?results).  Alternatively, running @doc results will also give you the same answers.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The results can easily be visualised through the GLMakie extension of the package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GLMakie\nplot(results)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This will open a GUI with tools to interactively extract some information from the inversion results, by selecting regions and labelling them accordingly.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Info\nThe plot function of GLMakie is modified by this package  to work with results from the invert function as arguments. It's really easy to use, but if you want more control  on how your plots look, it's best to create them from scratch  using all the tools available in GLMakie.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The process above can also be achieved by a single line of code:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using NMRInversions, GLMakie\nplot(invert(import_spinsolve()))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the workflow above can work for both 1D and 2D inversions!","category":"page"},{"location":"tutorial/#Examples-with-plots","page":"Tutorial","title":"Examples with plots","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This is how some full examples would look like:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using NMRInversions, GLMakie\n\npath = \".../NMRInversions.jl/example_data/csv_files/graphene_CPMG.csv\"\ndata = import_csv(IR, path)\nresults = invert(data)\nplot(results)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The resulting plot will look like:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Resulting plot)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice that benath the T_2 distribution there's a slider. You can move the ends of it to select a region within the limits defined by the red veritical lines. Then you can use the following options:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Label current selection will highlight the selected region  and add some text in the plot with the weighed average T_2 of that region.\nFilter-out current selection will remove the selected region  from the distribution, and it will update the fit and the residuals  accordingly on the plot.\nReset selections gets you back where you started, removes any  selections and brings back filtered-out regions.\nSave and exit will bring up a window so that you can save your   plot as a .png (without the buttons and the slider).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's look at a 2D example as well:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using NMRInversions, GLMakie\n\npaths = [\".../NMRInversions.jl/example_data/spinsolve_IRCPMG/T1IRT2.dat\",\n         \".../NMRInversions.jl/example_data/spinsolve_IRCPMG/aqcu.par\"]\ndata = import_spinsolve(paths)\nresults = invert(data)\nplot(results)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Resulting plot)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, now we can select regions by left-clicking at points within  the plot which enclose a region of interest. Then, we can :","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Label current selection will highlight the selected polygon  with a dashed line and add some text in the plot with the weighed  average T_1T_2 of that region, as well as the volume fraction of it.\nFilter-out unselected will remove everything outside the polygon.\nCancel current selection will discard the current polygon in   case you do not like what you selected.\nReset everything will get you back to the original state,   removing selections and restoring filtered-out regions.\nSave and exit will bring up a window so that you can save your   plot as a .png (without the buttons).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are also some options to change the appearance of the plot, in  terms of colormap, contour levels and toggling between filled and non-filled contours. You can also add a title to the plot, which will be saved.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you have multiple results, you can pass them as a matrix or vector  into the plot() function as:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot([results  results ; results results])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Resulting plot)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Of course, it would be more interesting if it wasn't four copies of the same results, but you get the point.","category":"page"},{"location":"tutorial/#Using-the-expfit-function","page":"Tutorial","title":"Using the expfit function","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In a similar way, we can perform various exponential  fits with the imported data using the expfit function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using NMRInversions, GLMakie\n\npath = \".../NMRInversions.jl/example_data/csv_files/Chesire_sandstone_IR.csv\"\ndata = import_csv(IR, path)\n\na = expfit(1, data)  # mono-exponential fit\nb = expfit(2, data)  # bi-exponential fit\n\nplot(a,b)  # Visualize both on the same plot","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Resulting plot)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Of course, these fits are not very good, that's why we'd use inversions  instead.","category":"page"}]
}
