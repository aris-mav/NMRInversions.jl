var documenterSearchIndex = {"docs":
[{"location":"functions/","page":"Functions","title":"Functions","text":"This page contains the documentation for various useful  functions in the NMRInversions package.\n\ntip: Tip\nFrom the Julia command line, you can enter '?',  followed by the name of any function, struct,  or object you want to learn more about (try it!). After typing using NMRInversions in the Julia console,  this feature will work for all the functions mentioned below.\n\ninfo: Info\nIn Julia, function definitions look like this:foo(x, y, z ; a, b)For the example above, foo is the name of the function,  and the contents of the parenteses are the arguments.   Within the parenteses, we got two types of arguments:Positional argumentsEverything that appears before the semicolon ;  (x,y and z in this example) is necessary, and must be given in a specific order.Keyword arguments.Everything that appears after the semicolon ;  (b and a in this example) is optional, and can be given in any order, but its name must be specified.In the example above, we can call the function by typing foo(1, 2, 3), (in which case, x=1, y=2, z=3, and the default value for a and b will be used).  You can also call the function by typing foo(1, 2, 3, a=3), to specify the value for a,  or by typing foo(1, 2, 3, b=3, a = 2), to specify the value for both a and b.Sometimes, if there are many keyword arguments, we write  the function as foo(x, y ; kwargs...).  For the necessary arguments before the semicolon, order matters.  For the keyword arguments after the semicolon, order does not matter,  but the name of each argument must be specified. For more information, please refer to this link.","category":"section"},{"location":"functions/#Importing-data","page":"Functions","title":"Importing data","text":"This package offers some functions to import NMR experiment data of various formats. Alternatively, you can of course import your data however you see fit. If a format you're working with is not yet supported,  please submit an issue  and we'll work on it.\n\nThe most basic use case would be using data saved in a csv format,  where there are only two columns,  one for your x-axis (time for relaxation and b-factor for diffusion) and one for your y-axis (signal intensity).\n\nIf you're using a spinsolve instrument, you can use the import_spinsolve function. This one requires two files as an input.  The aqcu.par is automatically exported by SpinsolveExpert,  but you might have to export your data file manually in a csv format.\n\nFor geospec instruments, you can export your raw data as a text file. That text file can be read by the import_geospec function.\n\nFor.tnt files from Tecmag consoles, import_tnt can be used. It should be noted however, that since pulse sequence implementations might vary, automatic parsing of the data into a input1D or input2D struct might fail. Therefore, the more manual read_tnt_data and read_tnt_header functions can be used for fine-tuned cases. If that sounds confusing, please submit an issue and we'll work on it!","category":"section"},{"location":"functions/#Inversion","page":"Functions","title":"Inversion","text":"The most important function is invert(), which is the main function of the package. It works as follows:\n\nDue to Julia's multiple dispatch,  it is possible to define a function with the same name but different arguments, to achieve different results.\n\nBecause of that, the inversion function also works for 2D inversions, if the following arguments are used instead:","category":"section"},{"location":"functions/#Finding-alpha","page":"Functions","title":"Finding alpha","text":"Here we provide two options for finding the optimal value for alpha,  namely Generalized Cross Validation (GCV) or L-curve.  Generally gcv seems slightly more reliable in NMR, but it's far from  perfect, so it's good to have alternatives and cross-check. The following methods can be used as inputs for the alpha argument in the invert function:\n\nThe gcv() method [2] usually involves the least amount of  function calls and it is thus much faster, thus used as the default option. If you want more precision, the univariate or box methods should be used instead. Note that gcv() will NOT work for pdhgm() solver, so you'll have to choose  an alternative explicitly when using that solver.","category":"section"},{"location":"functions/#Exponential-fits","page":"Functions","title":"Exponential fits","text":"For 1D data, we can use the expfit function to perform multiexponential fits. We can use the function by specifying either the number of exponential components, or a vector which defines the starting points for the regression. See below:\n\nIf you have some rough clue about what results you expect,  it's best to define some starting points close to these. (especially important if you're using double or tri-exponential fits.)","category":"section"},{"location":"functions/#Plotting","page":"Functions","title":"Plotting","text":"This package offers plotting capabilities, using its GLMakie extension. Simply use using GLMakie before or after using NMRInversions to load the package, and these functions become available.\n\nWe basically take the plot() function offered by GLMakie and extend it to types from the package.\n\nYou can use plot() for input1D or input2D structures coming from import functions, e.g.:\n\ndata = import_csv(IR, \"./path/to/file.csv\")\nplot(data)\n\nSimilarly, for inversion results:\n\ndata = import_csv(IR, \"./path/to/file.csv\")\nresults = invert(data)\nplot(results)\n\nUsing a matrix or vector of inv_out_1D or inv_out_2D structures (e.g. plot([results1, results2, results3]) will plot all of them on the same figure, for a quick comparison.","category":"section"},{"location":"functions/#Data-plots","page":"Functions","title":"Data plots","text":"","category":"section"},{"location":"functions/#1D-inversion-plots","page":"Functions","title":"1D inversion plots","text":"","category":"section"},{"location":"functions/#2D-inversion-plots","page":"Functions","title":"2D inversion plots","text":"","category":"section"},{"location":"functions/#Expfit-plots","page":"Functions","title":"Expfit plots","text":"","category":"section"},{"location":"functions/#Miscellaneous","page":"Functions","title":"Miscellaneous","text":"","category":"section"},{"location":"functions/#Weighted-averages","page":"Functions","title":"Weighted averages","text":"Once you have selected some peaks in your inversion results through the GUI, you might want to extract the weighted averages of these selected peaks, to get the underlying relaxation times or diffusion coefficients. The following functions do the job:\n\nFor example:\n\nresults = invert(my_data)\nplot(results)\n\"Select regions interactively through the GUI\"\nweighted_averages(results)","category":"section"},{"location":"functions/#Trimming-data","page":"Functions","title":"Trimming data","text":"If you want a \"quick and dirty\" way to exclude some data points from your imported data, you may use the 'trim' function.\n\nYou can use the output of trim() directly as the inversion input:\n\ninvert(trim(import_csv(CPMG,\"/path/to/data\") , 3 ))\n\nThe one-liner above will remove the first three data points from the data and pass that into the inversion function.","category":"section"},{"location":"functions/#NMRInversions.import_csv-Tuple{Type{<:pulse_sequence1D}, String}","page":"Functions","title":"NMRInversions.import_csv","text":"import_csv(seq, file)\n\nImport data from a CSV file. The function reads the file and returns an input1D structure.\n\nseq is the 1D pulse sequence (e.g. IR, CPMG, PFG)\nfile is the path to the CSV file which contains the data (x, y) in two respective columns.\n\nThe function can be called without the seq argument, and the output will be the x and y vectors  (use it like, x,y =import_csv()). Alternatively, the function can also be called with only the seq argument, in which case a file dialog will open to select the file (use it like, data = import_csv(IR))\n\nPlease note that this function will just import the data as is, without any unit conversions.  Ensure that your x-axis is in seconds for relaxation,  or in seconds/metres² * 1e-9 for PFG experiments.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.import_spinsolve-Tuple{String}","page":"Functions","title":"NMRInversions.import_spinsolve","text":"import_spinsolve(files)\n\nImport data from a Spinsolve expert experiment.  Two paths must be provided as follows (order is not important):\n\nfiles = [.../datafile.csv , .../acqu.par] \n\nCalling this function without an argument by typing import_spinsolve() will open a file dialogue to select the files.\n\nThe function reads the acqu.par.bak file to get the  acquisition parameters, and the .dat file to get the data.  The function returns an input2D structure.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.import_geospec-Tuple{String}","page":"Functions","title":"NMRInversions.import_geospec","text":"import_geospec(dir)\n\nImport data from a .txt format, as exported by Geospec instruments.\n\nThe function reads the relevant information, performs a phase correction on the data, and returns an input1D or input2D structure.\n\nCalling this function without an argument by typing import_geospec()  will open a file dialog to select the .txt file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.import_tnt-Tuple{Type{<:Union{pulse_sequence1D, pulse_sequence2D}}, String}","page":"Functions","title":"NMRInversions.import_tnt","text":"import_tnt(seq, filename)\n\nRead data from a tecmag .tnt file, and return a input1D or input2D object with  all the relevant information.\n\nThis function is experimental, and since tecmag consoles work mainly with  custom pulse sequences, it might not cover some cases.  If it does not work for you, please submit an issue.\n\nNecessary (positional) arguments:\n\nseq is the pulse sequence (e.g. IR, CPMG, PFG)\nfilename is the path of the file containing the data.\n\nOptional (keyword) arguments:\n\nechotime is the string that is used to denote the Echo time as\n\ndefined in the pulse sequence. Default value is \"Echo_Time\".\n\nCalling this function without a filename argument, e.g.: import_tnt(seq),  will open a file dialogue to select the .tnt file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.read_tnt_data-Tuple{String}","page":"Functions","title":"NMRInversions.read_tnt_data","text":"read_tnt_data(filename::String)\n\nRead raw data from  a tecmag .tnt file and return a  complex vector containing all the values.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.read_tnt_header-Tuple{String}","page":"Functions","title":"NMRInversions.read_tnt_header","text":"read_tnt_header(filename::String)\n\nRead the header of a .tnt file and return a dictionary  with all the relevant information.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.invert-Tuple{Type{<:pulse_sequence1D}, AbstractArray, Vector}","page":"Functions","title":"NMRInversions.invert","text":"Inversion for 1D pulse sequences:\n\ninvert(seq, x, y ; lims, alpha, solver, normalize)\n\nThis function will build a kernel and use it to perform an inversion using the algorithm of your choice. The output is an inv_out_1D structure.\n\nNecessary (positional) arguments:\n\nseq is the 1D pulse sequence (e.g. IR, CPMG, PFG)\nx is the experiment x axis (time or b factor etc.)\ny is the experiment y axis (intensity of the NMR signal)\n\nOptional (keyword) arguments:\n\nlims=(a,b,c) will set the \"limits\" of the output X, \n\nso that it starts from 10^a, ends in 10^b and consists of c  logarithmically spaced values. Alternatively, a vector of values can be used directly, if more freedom is needed  (e.g. lims=exp10.(range(-4, 1, 128))). By default, 128 points are used, logarithmically spaced between the first value  in x divided by 7, and the final value in x multiplied by 7.\n\nalpha determines the smoothing term. Use a real number for a fixed alpha, \n\nor look at the \"Types and Structures - Finding Optimal Alpha\" section of the  documentation for other options.   No selection will lead to automatically determining alpha through the  default method, which is gcv().\n\nsolver is the algorithm used to do the inversion math. Default is brd().\nnormalize will normalize y to 1 at the max value of y. Default is true.  \nsilent will suppress the output of the alpha search. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.invert-Tuple{input1D}","page":"Functions","title":"NMRInversions.invert","text":"invert(data::input1D ; kwargs...)\n\nInstead of the positional arguments seq, x and y, you can use a single input1D structure, which contains the same information.  Especially useful if you're using the output of one  of the import functions (look documentation tutorial section).\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.invert-Tuple{Type{<:pulse_sequence2D}, AbstractVector, AbstractVector, AbstractMatrix}","page":"Functions","title":"NMRInversions.invert","text":"Inversion for 2D pulse sequences:\n\ninvert(seq, x_direct, x_indirect, Data; lims1, lims2, alpha, solver, normalize)\n\nThis function will build a kernel and use it to perform an inversion using the algorithm of your choice. The output is an inv_out_2D structure.\n\nNecessary (positional) arguments:\n\nseq is the 2D pulse sequence (e.g. IRCPMG)\nx_direct is the direct dimension acquisition parameter (e.g. the times when you aquire CPMG echoes).\nx_indirect is the indirect dimension acquisition parameter (e.g. all the delay times τ in your IR sequence).\nData is the 2D data matrix of complex data.\n\nOptional (keyword) arguments:\n\nlims1 determines the output \"range\" of the inversion in the direct dimension (e.g. T₂ times in IRCPMG)\nlims2 determines the output \"range\" of the inversion in the indirect dimension (e.g. T₁ times in IRCPMG)\n\nIn both cases above, you can use a tuple specifying the limits of the range,  or a vector of values, same as the lims argument in the 1D inversion function. By default, 64 points are used, logarithmically spaced between the first value  in x divided by 7, and the final value in x multiplied by 7 (for both direct and indirect x).\n\nalpha determines the smoothing term. Use a real number for a fixed alpha.  No selection will lead to automatically determining alpha through the default method, which is gcv.\nsolver is the algorithm used to do the inversion math. Default is brd().\nnormalize will normalize Data so that its maximum value is 1. Default is true.\nsilent will suppress the output of the alpha search. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.invert-Tuple{input2D}","page":"Functions","title":"NMRInversions.invert","text":"invert(data::input2D ; kwargs...)\n\nInstead of the positional arguments seq, x_direct , x_indirect and Data, you can use a single input2D  structure, which contains the same information.  Especially useful if you're using the output of one of the  import functions (look documentation tutorial section).\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.gcv-Tuple{}","page":"Functions","title":"NMRInversions.gcv","text":"gcv()\n\nConstructor for the gcv method described in Mitchell 2012. No arguments required.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.gcv-Tuple{Real}","page":"Functions","title":"NMRInversions.gcv","text":"gcv(start; kwargs...)\n\nConstructor for finding the optimal alpha value via gcv score box optimization, given a starting value.\n\nNecessary (positional) arguments:\n\nstart is the starting alpha value. \n\nChoose something sensible, usually a value between 0.1 and 10 would work well.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is LBFGS(). Only first order optimizers can be chosen here.  For more details, refer to Optim.jl documentation.\n\nopts an Optim.Options() structure which can provide some preferences to the solver.\n\nPlease have a look here.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.gcv-Tuple{Real, Real}","page":"Functions","title":"NMRInversions.gcv","text":"gcv(lower, upper ; kwargs...)\n\nConstructor for finding the optimal alpha value via gcv score univariate optimization, given some lower and upper bounds.\n\nNecessary (positional) arguments:\n\nlower is the lower bound, or lowest alpha value the algorighm will consider.\nupper is the upper bound, or highest alpha value the algorighm will consider.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is Brent() and the only alternative is GoldenSection(), which is normally slower.\n\nabs_tol determines what's the smallest change in alpha the algorithm should care about.\n\nDefault is 1e-3.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.lcurve-Tuple{Real, Real, Int64}","page":"Functions","title":"NMRInversions.lcurve","text":"lcurve(lowest_value, highest_value, number_of_steps)\n\nConstructor for testing all L-curve curvatures between some bounds and  picking the optimal.\n\nlowest_value is the lowest alpha value.\nhighest_value is the highest alpha value.\nnumber_of_steps is the number of alpha values that will be tested.\n\nThis is a very crude and rather slow method, mostly for demonstration purposes.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.lcurve-Tuple{Real}","page":"Functions","title":"NMRInversions.lcurve","text":"lcurve(start; kwargs...)\n\nConstructor for finding the optimal alpha value via lcurve curvature box optimization, given a starting value.\n\nNecessary (positional) arguments:\n\nstart is the starting alpha value. \n\nChoose something sensible, usually a value between 0.1 and 10 would work well.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is LBFGS(). Only first order optimizers can be chosen here.  For more details, refer to Optim.jl documentation.\n\nopts an Optim.Options() structure which can provide some preferences to the solver.\n\nPlease have a look here.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.lcurve-Tuple{Real, Real}","page":"Functions","title":"NMRInversions.lcurve","text":"lcurve(lower, upper ; kwargs...)\n\nConstructor for finding the optimal alpha value via lcurve curvature univariate optimization, given some lower and upper bounds.\n\nNecessary (positional) arguments:\n\nlower is the lower bound, or lowest alpha value the algorighm will consider.\nupper is the upper bound, or highest alpha value the algorighm will consider.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is Brent() and the only alternative is GoldenSection(), which is normally slower.\n\nabs_tol determines what's the smallest change in alpha the algorithm should care about.\n\nDefault is 1e-3.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.expfit-Tuple{Union{Int64, Vector{<:Real}}, Type{<:pulse_sequence1D}, Vector, Vector}","page":"Functions","title":"NMRInversions.expfit","text":"expfit(n, seq, x, y; kwargs...)\n\nFit an n-exponential function to the data x and y. \n\nThe outut is an expfit_struct structure.\n\nArguments:\n\nn : Integer specifying the number of exponential terms.\nseq : pulse sequence.\nx : acquisition x parameter (time for relaxation or b-factor for diffusion).\ny : acquisition y parameter (magnetization).\n\nOptional arguments:\n\nsolver : Optim solver, default choice is IPNewton().\nnormalize : Normalize the data before fitting? (default is true).\nL : An integer specifying which norm of the residuals you want to minimize (default is 2).\n\nThe n argument can also be a vector of initial parameter guesses,  in which case it also determines the number of exponential terms used. It should be of the form [a1, b1, a2, b2, ...],  where a's are the amplitudes and b's are the parameters inside the exponentials.\n\nThe length of the vector in this case must be an even number.\n\nThe following examples might help to clarify: \n\nexpfit([a,b] , CPMG, x, y) -> mono-exponential fit with initial guess: a * exp.( (1/b) * x) \n\nexpfit([a,b,c,d] , CPMG, x, y) -> bi-exponential fit with initial guess: a * exp.( (1/b) * x) + c * exp.((1/d) * x) \n\nexpfit([a,b,c,d,e,f] , CPMG, x, y) -> tri-exponential fit with initial guess: a * exp.( (1/b) * x) + c * exp.((1/d) * x) + e * exp.((1/f) * x) \n\n(where a,b,c,d,e,f are numbers of your choice)\n\nNumbers of parameters beyond tri-exponential can also be used, but it is not recommended.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.expfit-Tuple{Union{Int64, Vector{<:Real}}, input1D}","page":"Functions","title":"NMRInversions.expfit","text":"expfit(n, data; kwargs...)\n\nSimilar to the invert function, expfit can be called using an input1D structure.\n\nArguments:\n\nn : Integer specifying the number of exponential terms.\ndata : input1D structure containing the data to be fitted.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Makie.plot-Tuple{input1D}","page":"Functions","title":"Makie.plot","text":"plot(data::input1D)\n\nQuickly visualise the contents of a 1D NMR data structure.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Makie.plot-Tuple{input2D}","page":"Functions","title":"Makie.plot","text":"plot(data::input2D)\n\nInteractive GUI to visualise the contents of a 2D NMR data structure.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Makie.plot-Tuple{inv_out_1D}","page":"Functions","title":"Makie.plot","text":"plot(res::inv_out_1D)\n\nRun the GUI to plot the 1D inversion results and select peaks you want to label.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Makie.plot-Tuple{VecOrMat{inv_out_1D}}","page":"Functions","title":"Makie.plot","text":"plot(res_mat::VecOrMat{inv_out_1D};kwargs...)\n\nPlot the results contained in a vector of inv_out_1D structures.\n\nThe keyword (optional) arguments are:\n\nselections : Whether to highlight the selections in the plots (default is false).\n\n\n\n\n\n","category":"method"},{"location":"functions/#Makie.plot-Tuple{inv_out_2D}","page":"Functions","title":"Makie.plot","text":"Makie.plot(res::inv_out_2D)\n\nRun the GUI to plot the results and select peaks you want to label.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Makie.plot-Tuple{AbstractVecOrMat{inv_out_2D}}","page":"Functions","title":"Makie.plot","text":"plot(results::AbstractVecOrMat{inv_out_2D}; kwargs...)\n\nPlot the results contained in a matrix of inv_out_2D structures. The arrangement is determined by the shape of the matrix.\n\nThe arguments are:\n\nresults : The inv_out_2D matrix or vector containing the fit results.\n\nKeyword (optional) arguments:\n\ndims : Dimensions of each plot (default: (400, 400)).\ntitle : Title of the plot (default: \"\").\ncolormap : Color map of the plot (default: :viridis).\ncontf : Whether to use a filled contour plot (default : false).\nlevels : Number of contour levels (default: 40).\nlabelsizes : Size of the axis labels (default: (23, 23)).\nticksizes : Size of the axis ticks (default: (14, 14)).\ntitlesize : Size of the title (default: 17).\ntitlefont : Font of the title (default: :bold).\nlegendlabelsize : Size of the legend label (default: 12)\ngap : The gap between the contour plot and the distribution plots (default: 0)\nextend_grid : Whether to extend the gridlines to the plots on the sides (default: false)\nlegendposition : Where to put the legend (default: :lt )\nbandplots : Whether to use band plots to highlight the selections in the top and right distributions (default: true)\n\n\n\n\n\n","category":"method"},{"location":"functions/#Makie.plot-Tuple{expfit_struct}","page":"Functions","title":"Makie.plot","text":"plot(res::expfit_struct...; kwargs...)\n\nPlot the results of an expfit call. \n\nThis function can take any number of expfit_struct structures as input. \n\ne.g. plot(data1) plots the data and the corresponding fit, but plot(data1, data2) or plot(data1, data2, data3) work as well, and they plot all of the results on the same plot.\n\nKeyword (optional) arguments:\n\nmarkersize : The size of the markers (default is 7).\nnormeq : Whether to plot the normalised form of the equation or not (default is true).\nyscale : The scale of the y-axis (default is identity).\n\n\n\n\n\n","category":"method"},{"location":"functions/#Makie.plot!-Tuple{Union{GridPosition, Figure}, expfit_struct}","page":"Functions","title":"Makie.plot!","text":"plot!(fig, res...; names, markersize, normeq)\n\nPlots the results of an expfit call on a figure or a grid position object.\n\nThe arguments are:\n\nfig : The figure or grid position object.\nres : One or more expfit_struct structures containing the fit results.\n\nKeyword (optional) arguments:\n\nmarkersize : The size of the markers (default is 7).\nnormeq : Whether to plot the normalised form of the equation or not (default is true).\nyscale : The scale of the y-axis (default is identity).\n\nNote that the res inputs are not a vector, but individual expfit_struct structures, like: plot!(fig, data1, data2, data3). If you want to use a vector of expfit_struct structures, make sure to  splat it by using ... in the function call (e.g. plot!(fig, [data1, data2, data3]...)).\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.weighted_averages-Tuple{inv_out_1D}","page":"Functions","title":"NMRInversions.weighted_averages","text":"weighted_averages(r::inv_out_1D)\n\nReturn a vector with the weighted averages for  the selections in the input structure, and a  vector with the respective area fractions of  these selections.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.weighted_averages-Tuple{inv_out_2D}","page":"Functions","title":"NMRInversions.weighted_averages","text":"weighted_averages(r::inv_out_2D)\n\nReturn two vectors with the weighted averages  for the selections in the input structure, one for each dimension, as well as a vector with the volume fractions of these selections.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.trim-Tuple{input1D, Int64, Int64}","page":"Functions","title":"NMRInversions.trim","text":"trim(::input1D, ::Int=0, ::Int=0)\n\nReturn an input1D structure which excludes a selected  amount of points from the beginning and the end of the  x and y arrays. \n\nFor example, trim(data,2,3) will remove the first 2 and  the last 3 data points.\n\n\n\n\n\n","category":"method"},{"location":"functions/#NMRInversions.trim-Tuple{input2D}","page":"Functions","title":"NMRInversions.trim","text":"trim(::input2D; direct::Tuple{Int,Int}=(0,0), indirect::Tuple{Int,Int}=(0,0))\n\nReturn an input2D structure which excludes a selected  amount of points from the beginning and the end of the  direct and indirect dimensions of the data matrix, respectively. \n\nFor example, trim(data, direct=(2,3), indirect=(1,4)) will remove the first 2  and the 3 last columns of the data matrix, as well as the first  row and the last four rows.\n\nThat means, for T1T2 data, you will remove the first 2 and last 3 echo points for T2 (direct dimension), and the first 1 and last 4 inversion recovery  points (indirect dimension).\n\n\n\n\n\n","category":"method"},{"location":"references/","page":"References","title":"References","text":"P. C. Hansen. Discrete inverse problems: Insight and algorithms (Society for Industrial and Applied Mathematics, 2010).\n\n\n\nJ. Mitchell, T. Chandrasekera and L. Gladden. Numerical estimation of relaxation and diffusion distributions in two dimensions. Progress in nuclear magnetic resonance spectroscopy 62, 34–50 (2012).\n\n\n\nY.-Q. Song, L. Venkataramanan, M. Hürlimann, M. Flaum, P. Frulla and C. Straley. T1–T2 Correlation Spectra Obtained Using a Fast Two-Dimensional Laplace Inversion. Journal of Magnetic Resonance 154, 261–268 (2002).\n\n\n\nL. Venkataramanan, Y.-Q. Song and M. Hurlimann. Solving Fredholm integrals of the first kind with tensor product structure in 2 and 2.5 dimensions. IEEE Transactions on Signal Processing 50, 1017–1026 (2002).\n\n\n\nN. Bloembergen, E. M. Purcell and R. V. Pound. Relaxation Effects in Nuclear Magnetic Resonance Absorption. Phys. Rev. 73, 679–712 (1948).\n\n\n\nT. C. Chandrasekera and J. Mitchell. Numerical inversion methods for recovering negative amplitudes in two-dimensional nuclear magnetic resonance relaxation-time correlations. Phys. Rev. E 98, 043308 (2018).\n\n\n\nA. Reci, A. Sederman and L. Gladden. Obtaining sparse distributions in 2D inverse problems. Journal of Magnetic Resonance 281, 188–198 (2017).\n\n\n\n","category":"section"},{"location":"savefiles/","page":"Saving data","title":"Saving data","text":"Julia provides the Serialization.jl package to save and load data in a binary format. This provides us with a straightforward way to save our results in a file, and load them later if we need to check what's inside them.\n\ninfo: Info\nSerialization.jl and DelimitedFiles.jl are both part of the  standard library, and thus it can be used without installation.","category":"section"},{"location":"savefiles/#Saving-results","page":"Saving data","title":"Saving results","text":"Assuming that we have a variable results which contains our data, (e.g., results is a inv_out_2D structure), we can use the following example to save them in a file.\n\nusing Serialization\n\n# Save the results in a file named \"results.dat\"\n# using the serialize function\nserialize(\"results.dat\", results)\n\n# Load the results\n# using the deserialize function\nresults = deserialize(\"results.dat\")\n\n\nNote that we use a \".dat\" file extension above, but you can  use whatever extension you like (or none), as long as it  makes sense to you.\n\nWriting into plain-text files in delimited formats is also possible, using the DelimitedFiles library and the writedlm function.\n\nWe have to choose which data to save. In this example below we  use the relaxation time (or diffusion coefficient) distribution.\n\nusing DelimitedFiles\n\ndata_matrix = [results.X results.f]\n\n# The third parameter in the function below\n# determines the delimiter, in this case a comma\nwritedlm(\"data.csv\", data_matrix, ',')\n\nThis might be useful if you want to export the data into any non-julia software. For more elaborate formats, you could have a look at packages  such as TOML.jl or JSON.jl.","category":"section"},{"location":"savefiles/#Saving-plots","page":"Saving data","title":"Saving plots","text":"You can use the 'save' function provided by GLMakie to save plots.\n\nusing NMRInversions, GLMakie\n\ndata = import_csv(IR)\nresults = invert(data)\np = plot(results)\n\nsave(\"results.png\", p)\n\n\nThis will save the plot p in the file path results.png.\n\nIf you'd rather use a file dialog to specify the path interactively, you can do something like:\n\nsave(NMRInversions.save_file(\"\", filterlist = \"png\") , p)\n\n\nThis will open a file dialog, where you can interractively select where to save the image.\n\nNote that for 2D data, the plot GUI already has a \"Save and exit\" button which  can be used to save the plot in the same way.","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"What follows is a rough explanation of what this package is about. If you're looking for more rigor, please refer to sources  [1–4] in the  References section. If you believe something mentioned below is wrong or misleading, please submit an issue.","category":"section"},{"location":"theory/#Exponentials-in-NMR","page":"Theory","title":"Exponentials in NMR","text":"For NMR relaxation and diffusion experiments in liquids, we expect the results we get to look more or less like an exponential decay  or recovery, as described by the BPP theory [5].\n\nTo obtain useful information from NMR experiments, we can use different  exponential forms, according to the pulse sequence used.\n\nExamples are : \n\nPulse sequence Equation\nInversion recovery M = 1 - 2( exp(-tT_1) )\nSaturation recovery M = 1 - exp(-tT_1)\nCPMG M = exp(-tT_2)\nPGSE M = exp(-b * D)\n\n, where M is the magnetization (the \"signal\" you would record in such an  experiment, normalized so that its maximum value is 1), t is time, T_1  and T_2 are relaxation time constants, b is the b-factor in the  Stejskal-Tanner equations, and D is diffusion coefficient.\n\nThis is all good if the sample you want to study is nice and simple  (e.g., a liquid made up of a single type of molecule), and you can fit your   data using the equations above to obtain the desired quantity, which would be  either T_1, T_2, or D. ","category":"section"},{"location":"theory/#Multi-exponential-forms","page":"Theory","title":"Multi-exponential forms","text":"If the NMR data comes from a system which is to some degree inhomogenous, e.g. has multiple pore environments, several different liquids, etc.,  we would expect for the data to be a sum of exponentials, one for each of the underlying components.\n\nFor example, if we do a CPMG experiment on a mixture of water and ethanol, we would expect the equation to look like :\n\nM = alpha exp(-tT_2 water) + beta exp(-tT_2 ethanol)  \n\nwhere alpha and beta would represent the fractions of  water and ethanol spins into the system, respectively.\n\nOf course, there's no reason to stop at two components. The more general form could be written as :\n\nM = sum_k=1^n f_k exp(-tT_2k)  \n\nwhere n is the total number of different components hidden behind the data, and f_k is the fraction of the kth component.","category":"section"},{"location":"theory/#Exponential-fits","page":"Theory","title":"Exponential fits","text":"Normally, we would use some type of nonlinear regression to handle cases where we already know that the system we  study is made up of a limited number of components  (n would be 1,2 or maybe 3).  This package covers this case using the expfit(n, data) function.\n\nHowever, in a lot of realistic scenarios, this method fails for a few reasons:\n\nWe don't always know exactly how many components our system is made out of.\nThere might be a virtually continuous range of relaxation times (or diffusion  coefficients) within the system, e.g. a fluid within a rock sample with  many different pore sizes might have a different relaxation time for each pore size.\nWhen we add too many degrees of freedom by introducing lots of free  variables in the fit equation, it's easy for the algorithm to converge in nonsensical values which just happen to be close to the starting points  and yield a low-enough value for the cost function. The fit could be satisfying, but the values might be unrealistic and unreliable.","category":"section"},{"location":"theory/#Inversions","page":"Theory","title":"Inversions","text":"In linear algebra terms, a discrete version of the equation :\n\nM = sum_k=1^n f_k exp(-tT_2k)   \n\ncan be written as :\n\nKf = g  \n\nwhere :\n\ng is a vector containing the M values recorded from an experiment,\nf is a vector containing the f_k values present in the system,\nK is a \"kernel\" matrix, which can be constructed for a predetermined, usually logarithmically-spaced range of T_2 values.\n\nWhat we are interested in is to solve for the f vector, since  g is already known and K can be constructed according to the range of  T_2 values we're looking for (or T_1, or D).\n\nThe \"naive\" way to approach this would be to use the inverse of the K matrix, and  solve the problem as \n\nf = K^-1g  \n\nHowever the resulting f would be terrible for a few reasons:\n\nEven small amounts of noise in the data would mess up the results due to the very large  condition number of the K matrix. \nSince there will be some amount of noise in g, we would not even want our fit  curve (Kf) to be exactly equal to the data (g), since that would involve fiting  the noise.\nNegative values in f would be okay with this method, which does not make much  sense since we can't have negative amounts of relaxation times  (unless you have a reason to allow that [6]).\n\nThis is a textbook example of an inverse problem.\n\nThe most commmon way to approach it would be Tikhonov regularization, where we solve the following optimization problem : \n\nmin_f geq 0  Kf-g_2^2 + alpha f_2^2  \n\nwhere alpha is a scalar value referred to as the \"regularization parameter\".\n\nThis way, we minimize the residuals (Kf-g) while preventing the norm of the   solution (f) from getting out of control due to the noise in g.\n\nLow values of alpha would result in noisy, unregularized solutions with spikey T or D distributions, while large alpha's would lead to very broad, over- smoothed distributions.\n\nThe invert function in this package solves this problem, and automatically finds the  optimal value for alpha using the GCV method. There is also an option to use the  L-curve method to find alpha, or supply a constant value for it.","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you would like to contribute to the package, you may start with one of  the existing issues. Please feel free to create a pull request if you'd like to implement a feature. Stanard Julia style  is recommended, and writing tests for any new (or existing) features would be nice.\n\nIf you're unsure about anything or need further guidance, feel free to start a discussion.","category":"section"},{"location":"installation/#Installing-Julia","page":"Installation","title":"Installing Julia","text":"You can download the Julia programming language by following this link. Afterwards, you can either use the Julia console (aka REPL)  by finding the Julia .exe file in your computer, or you can use VScode, which provides an environment similar to MATLAB with the use of the  Julia extension (follow link for installation instructions).  Of course, if you already have a preferred development workflow  and you know what you're doing, by all means go for it.","category":"section"},{"location":"installation/#Installing-the-package","page":"Installation","title":"Installing the package","text":"The package can be installed by running the following command on the Julia console:\n\nusing Pkg ; Pkg.add(\"NMRInversions\")\n\nThis usually takes a while, but it needs to be done only once  (unless you swap environment, more on that  here).\n\nAfterwards, you can use the package by running \n\nusing NMRInversions\n\nin your Julia console, every time you start a new session.\n\nWhenever a new version comes up, you can run:\n\nusing Pkg ; Pkg.update(\"NMRInversions\")\n\nto update the package.","category":"section"},{"location":"installation/#GLMakie-extension","page":"Installation","title":"GLMakie extension","text":"The package provides an extension for interactive visualization, using the GLMakie package. To gain access to these capabilities, you also need to install GLMakie:\n\nusing Pkg ; Pkg.add(\"GLMakie\")\n\nAnd to use it, you need to run\n\nusing GLMakie\n\nin order to access the plotting functions.","category":"section"},{"location":"types_structs/","page":"Types and Structures","title":"Types and Structures","text":"In order to take advantage of Julia's multiple dispatch,  we need to define some structures which can be used as input to our functions.\n\ninfo: Info\nStructures are object which may contain multiple fields. The fields can be accessed using the dot syntax. For example, if we have a structure named foo, with two fields, a, and b,  we can access the value of a using foo.a and the value of b using foo.b.","category":"section"},{"location":"types_structs/#Pulse-sequences","page":"Types and Structures","title":"Pulse sequences","text":"The following types are used so that the invert function  can create the appropriate kernel for the inversion.  Anywhere you see the seq keyword, one of the following must be used.","category":"section"},{"location":"types_structs/#Inversion-solvers","page":"Types and Structures","title":"Inversion solvers","text":"These are used to let the invert fucntion know which solver to use. They can be used as input to the invert function as the 'solver' argument. (e.g., invert(data, solver=brd()) [3] or  invert(data, solver=pdhgm(10,0.1) )) [7].","category":"section"},{"location":"types_structs/#Finding-optimal-alpha","page":"Types and Structures","title":"Finding optimal alpha","text":"These are methods for finding the optimal regularization parameter.  They can be used as input to the invert function as the 'alpha' argument (e.g., invert(data, alpha=gcv()) or invert(data, alpha=lcurve(0.001,1,64)) ). If you'd like to use a particular value of alpha,  you can just use that number instead (invert(data, alpha=1)).","category":"section"},{"location":"types_structs/#Inversion-and-expfit-inputs","page":"Types and Structures","title":"Inversion and expfit inputs","text":"These can be used as inputs containing all of the necessary information to run the inversion and expfit functions  (e.g. if a is an input1D object, invert(a) does the job).","category":"section"},{"location":"types_structs/#Inversion-and-expfit-outputs","page":"Types and Structures","title":"Inversion and expfit outputs","text":"When you run an inversion function (e.g. r = invert(a)), the output is an inv_out_1D or inv_out_2D structure.","category":"section"},{"location":"types_structs/#Kernel-structure","page":"Types and Structures","title":"Kernel structure","text":"","category":"section"},{"location":"types_structs/#NMRInversions.IR","page":"Types and Structures","title":"NMRInversions.IR","text":"Inversion recovery pulse sequence for 1D relaxation experiments. It can be used wherever the seq argument is required. \n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.SR","page":"Types and Structures","title":"NMRInversions.SR","text":"Saturation recovery pulse sequence for 1D relaxation experiments. It can be used wherever the seq argument is required. \n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.CPMG","page":"Types and Structures","title":"NMRInversions.CPMG","text":"CPMG pulse sequence for 1D relaxation experiments. It can be used wherever the seq argument is required. \n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.PFG","page":"Types and Structures","title":"NMRInversions.PFG","text":"Pulsed field gradient pulse sequence for 1D diffusion experiments. It can be used wherever the seq argument is required. \n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.IRCPMG","page":"Types and Structures","title":"NMRInversions.IRCPMG","text":"Inversion recovery - CPMG pulse sequence for 2D relaxation experiments (T1-T2). The direct dimension is the T2, and the indirect dimension is the T1 acquisition times. It can be used wherever the seq argument is required.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.brd","page":"Types and Structures","title":"NMRInversions.brd","text":"brd\n\nSolver for tikhonov (L2) regularization, following this paper [4]. Very fast, but only uses the identity as tiknohonov matrix. It can be used as a \"solver\" for the invert function.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.pdhgm","page":"Types and Structures","title":"NMRInversions.pdhgm","text":"pdhgm(σ, τ, tol)\n\nPrimal dual hybrid gradient method for L1 regularization,  following this paper [7].\n\nIt can be used as a \"solver\" for the invert function.\n\nPositional (keyowrd) arguments:\n\nsigma (default value 10)\ntau (default value 0.1)\ntol (default value 1e-5)\n\nThe particular choice of σ and τ is heuristic.  The parameters σ and τ are step size parameters, which control convergence and stability of the algorithm. Convergence is guaranteed  when τσ ≤ 1.\n\nThe best values of σ and τ will depend slightly on the scaling of the signal.  Therefore, it is best to normalize the NMR signal to a maximum of 1  (this is default for the invert function, no need to do anything).\n\nfor convenience.\n\nNote that for this method, the role of α is inverted, with larger α values leading to less smoothing, not more. For that reason, alpha=gcv() (Mitchell method) will not work. Please use alpha=gcv(starting_value) or `alpha=gcv(lowerlimit, upperlimit)', or some lcurve method instead.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.cdL1","page":"Types and Structures","title":"NMRInversions.cdL1","text":"cdL1(; iterations, tol)\n\nCoordinate descent method for L1 regularization.\n\nIt can be used as a \"solver\" for the invert function.\n\nAccepts two keyword (optional arguments):\n\niterations is an integer declaring the maximum amount of iterations before the algorithm stops (default value 10000).\ntol is the relative tolerance (default value 1e-5)\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.optim_nnls","page":"Types and Structures","title":"NMRInversions.optim_nnls","text":"optim_nnls(order)\n\nSimple non-negative least squares method for regularization,  implemented using Optim.jl. All around effective, but can be slow for large problems, such as 2D inversions. It can be used as a \"solver\" for invert function.\n\norder is an integer that determines the tikhonov matrix \n\n(for more info look Hansen's 2010 book on inverse problems).  Order n means that the penalty term will be the n'th derivative of the results. \n\nn detemines which norm of the loss function will be minimized. \n\nDefault is 2 (tikhonov regularization), but 1 is not the same as L1 regularization,  as both the residual term and the penalty term will be 1-norms, not just the penalty.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.jump_nnls","page":"Types and Structures","title":"NMRInversions.jump_nnls","text":"jump_nnls(order, solver)\n\nJump non-negative least squares method for tikhonov (L2) regularization,  implemented using the JuMP extension. All around effective, but can be slow for large problems, such as 2D inversions,  unless a powerful solver like gurobi is used.\n\nsolver is passed directly into JuMP. \norder determines the tikhonov finite-difference matrix. If 0 is chosen, the identity matrix is used.\n\nThis one is still experimental and not well-tested,  please submit an issue if you encounter any difficulties.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.gcv","page":"Types and Structures","title":"NMRInversions.gcv","text":"gcv()\n\nConstructor for the gcv method described in Mitchell 2012. No arguments required.\n\n\n\n\n\ngcv(start; kwargs...)\n\nConstructor for finding the optimal alpha value via gcv score box optimization, given a starting value.\n\nNecessary (positional) arguments:\n\nstart is the starting alpha value. \n\nChoose something sensible, usually a value between 0.1 and 10 would work well.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is LBFGS(). Only first order optimizers can be chosen here.  For more details, refer to Optim.jl documentation.\n\nopts an Optim.Options() structure which can provide some preferences to the solver.\n\nPlease have a look here.\n\n\n\n\n\ngcv(lower, upper ; kwargs...)\n\nConstructor for finding the optimal alpha value via gcv score univariate optimization, given some lower and upper bounds.\n\nNecessary (positional) arguments:\n\nlower is the lower bound, or lowest alpha value the algorighm will consider.\nupper is the upper bound, or highest alpha value the algorighm will consider.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is Brent() and the only alternative is GoldenSection(), which is normally slower.\n\nabs_tol determines what's the smallest change in alpha the algorithm should care about.\n\nDefault is 1e-3.\n\n\n\n\n\n","category":"function"},{"location":"types_structs/#NMRInversions.lcurve","page":"Types and Structures","title":"NMRInversions.lcurve","text":"lcurve(lowest_value, highest_value, number_of_steps)\n\nConstructor for testing all L-curve curvatures between some bounds and  picking the optimal.\n\nlowest_value is the lowest alpha value.\nhighest_value is the highest alpha value.\nnumber_of_steps is the number of alpha values that will be tested.\n\nThis is a very crude and rather slow method, mostly for demonstration purposes.\n\n\n\n\n\nlcurve(start; kwargs...)\n\nConstructor for finding the optimal alpha value via lcurve curvature box optimization, given a starting value.\n\nNecessary (positional) arguments:\n\nstart is the starting alpha value. \n\nChoose something sensible, usually a value between 0.1 and 10 would work well.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is LBFGS(). Only first order optimizers can be chosen here.  For more details, refer to Optim.jl documentation.\n\nopts an Optim.Options() structure which can provide some preferences to the solver.\n\nPlease have a look here.\n\n\n\n\n\nlcurve(lower, upper ; kwargs...)\n\nConstructor for finding the optimal alpha value via lcurve curvature univariate optimization, given some lower and upper bounds.\n\nNecessary (positional) arguments:\n\nlower is the lower bound, or lowest alpha value the algorighm will consider.\nupper is the upper bound, or highest alpha value the algorighm will consider.\n\nOptional (keyword) arguments:\n\nalgorithm determines which method will be used by Optim.jl to solve the problem.\n\nDefault is Brent() and the only alternative is GoldenSection(), which is normally slower.\n\nabs_tol determines what's the smallest change in alpha the algorithm should care about.\n\nDefault is 1e-3.\n\n\n\n\n\n","category":"function"},{"location":"types_structs/#NMRInversions.input1D","page":"Types and Structures","title":"NMRInversions.input1D","text":"input1D(seq, x, y)\n\nA structure containing the following fields:\n\nseq is the 1D pulse sequence (e.g. IR, CPMG, PFG)\nx, the x values of the measurement (e.g time for relaxation or b-factor for diffusion).\ny, the y values of the measurement. \n\nIt can be used as an input for the invert and expfit functions.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.input2D","page":"Types and Structures","title":"NMRInversions.input2D","text":"input2D(seq, x, y)\n\nA structure containing the following fields:\n\nseq is the 2D pulse sequence (e.g. IRCPMG)\nx_direct is the direct dimension acquisition parameter (e.g. the times when you aquire CPMG echoes).\nx_indirect is the indirect dimension acquisition parameter (e.g. all the delay times τ in your IR sequence).\ndata is the 2D data matrix.\n\nIt can be used as an input for the invert function.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.inv_out_1D","page":"Types and Structures","title":"NMRInversions.inv_out_1D","text":"inv_out_1D(seq, x, y, xfit, yfit, X, f, r, SNR, α, selections, filter, title)\n\nOutput of the invert function for 1D pulse sequences. A structure containing the following fields:\n\nseq is the 1D pulse sequence (e.g. IR, CPMG, PFG)\nx, the x values of the measurement (e.g time for relaxation or b-factor for diffusion).\ny, the y values of the measurement.\nxfit, the x values of the fitted data.\nyfit, the y values of the fitted data.\nX, the x values of the inversion results.\nf, the inversion results.\nr, the residuals.\nSNR, the signal-to-noise ratio.\nα, the regularization parameter.\nselections, a vector of tuples whose elements indicate the first and last index of the selected peaks.\nfilter, a vector representing the mask used to filter and scale the data.\ntitle, a title describing the data.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.inv_out_2D","page":"Types and Structures","title":"NMRInversions.inv_out_2D","text":"inv_out_2D(seq, X_direct, X_indirect, F, r, SNR, α, filter, selections)\n\nOutput of the invert function for 2D pulse sequences. A structure containing the following fields:\n\nseq is the 2D pulse sequence (e.g. IRCPMG)\nX_direct, the x values of the direct dimension.\nX_indirect, the x values of the indirect dimension.\nF, the inversion results as a matrix.\nr, the residuals.\nSNR, the signal-to-noise ratio.\nalpha, the regularization parameter.\nfilter, apply a mask to filter out artefacts when plotting.\nselections, the selection masks (e.g. when you want to highlight some peaks in a T₁-T₂ map).\ntitle, a title describing the data.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.expfit_struct","page":"Types and Structures","title":"NMRInversions.expfit_struct","text":"Output of the expfit function. Structure containing information about multiexponential fits.\n\nThe fields are as follows:\n\nseq: The pulse sequence\nx : The x acquisition values (e.g. time for relaxation or b-factor for diffusion).\ny : The y acquisition values.\nxfit : An array with fitted x values (for plotting purposes).\nyfit : An array with fitted y values (for plotting purposes).\nu : The fitted parameters for the mexp function.\nu0 : The initial parameters for the mexp function.\nr : The residuals.\neq : The equation of the fitted function.\neqn : The equation of the initial function.\ntitle : A title describing the data.\n\n\n\n\n\n","category":"type"},{"location":"types_structs/#NMRInversions.svd_kernel_struct","page":"Types and Structures","title":"NMRInversions.svd_kernel_struct","text":"svd_kernel_struct(K,g,U,S,V)\n\nA structure containing the following fields:\n\nK, the kernel matrix.\nG, the data vector.\nU, the left singular values matrix.\nS, the singular values vector.\nV, the right singular values matrix.\n\nTo access the fields of a structure, we use the dot notation,  e.g. if the structure is called a and we want to access the kernel contained in there, we type a.K\n\n\n\n\n\n","category":"type"},{"location":"","page":"Overview","title":"Overview","text":"Welcome to NMRInversions.jl!\n\nThe goal is to provide an easy-to-use interface to process NMR  relaxation and diffusion data, completely free/open-source, and fully  written in Julia.\n\nFunctionality includes :\n\nImporting NMR data from various instrument manufacturers.\nPerforming numerical inversions and exponential fits with sensible default settings.\nInteractive visualization of results, through the GLMakie extension.\n\nWho would want to use this package :\n\nResearchers in chemistry, physics, and materials science who rely on NMR  to study molecular dynamics, diffusion and interactions.  NMRInversions.jl simplifies the process of data analysis, allowing researchers  to focus on their scientific questions rather than the intricacies of data processing.\nProfessionals in various fields such as food science, subsurface applications,  or materials engineering can utilize this package to analyze NMR data for quality  control, product development, and research purposes. \nStudents learning about NMR techniques can benefit from a straightforward tool  that helps them understand data processing and analysis.  Educators can use the package as a teaching aid in courses related to NMR or  inverse problems.\n\nHopefully this documentation will provide all the information you need to get started.\n\nThe Theory section should provide some info on what the package is really about.\nFor more details on how to use it, you can start by refering to the examples in the   tutorial.\nTo understand how things really work, have a look at the  Functions and Types and Structures sections.\nIf you have any problems or questions, please feel free to  submit an issue.","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page will give you a basic idea about how to use the NMRInversions package. For more details, it's best to refer to the functions page.\n\nhint: Hint\nAll of the commands mentioned below should be typed in the julia console,  or saved in a text file with the .jl extension, to be used  from a terminal with julia file.jl, or through an IDE such as VSCode.","category":"section"},{"location":"tutorial/#Performing-an-inversion","page":"Tutorial","title":"Performing an inversion","text":"Suppose we're working with data coming from a Spinsolve instrument Then we can do the following:\n\n(you can find some example data in the files of this package,  look at the github page for the example_data folder).\n\nusing NMRInversions\n\ndata = import_spinsolve()\n\ninfo: Info\nSince we called the import_spinsolve function without an argument,  it'll open a file dialog for us to select the files we want to import. (note that import_spinsolve requires two files, the aqcu.par file containing aqcuistion parameters, plus the .dat or .csv file  containing the experiment data.)\n\nNow we have the data imported, the inversion can be performed using a single line of code!\n\nresults = invert(data)\n\ninfo: Info\nThe results variable above is an inv_out_1D or inv_out_2D structure,  which contains all the relevant information produced by the inversion function. To access that information, we can look at the fields of the structure using the dot notation. The field names contained in the structure can be shown by using the REPL help mode  (typing ? at the julia> prompt), and typing the variable's name (in this case, ?results).  Alternatively, running @doc results will also give you the same answers.\n\nThe results can easily be visualised through the GLMakie extension of the package.\n\nusing GLMakie\nplot(results)\n\nThis will open a GUI with tools to interactively extract some information from the inversion results, by selecting regions and labelling them accordingly.\n\ninfo: Info\nThe plot function of GLMakie is modified by this package  to work with results from the invert function as arguments. It's really easy to use, but if you want more control  on how your plots look, it's best to create them from scratch  using all the tools available in GLMakie.\n\nThe process above can also be achieved by a single line of code:\n\nusing NMRInversions, GLMakie\nplot(invert(import_spinsolve()))\n\nNote that the workflow above can work for both 1D and 2D inversions!","category":"section"},{"location":"tutorial/#Examples-with-plots","page":"Tutorial","title":"Examples with plots","text":"This is how some full examples would look like:\n\nusing NMRInversions, GLMakie\n\npath = \".../NMRInversions.jl/example_data/csv_files/graphene_CPMG.csv\"\ndata = import_csv(IR, path)\nresults = invert(data)\nplot(results)\n\nThe resulting plot will look like:\n\n(Image: Resulting plot)\n\nNotice that benath the T_2 distribution there's a slider. You can move the ends of it to select a region within the limits defined by the red veritical lines. Then you can use the following options:\n\nLabel current selection will highlight the selected region  and add some text in the plot with the weighed average T_2 of that region.\nFilter-out selection will remove the selected region  from the distribution, and it will update the fit and the residuals  accordingly on the plot.\nReset selections gets you back where you started, removes any  selections and brings back filtered-out regions.\nChange y scale will change the 1st plot from linear scale to log   scale and back. Only works if there are no negative values (so it will   not work for inversion recovery data).\nSave and exit will bring up a window so that you can save your   plot as a .png (without the buttons and the slider).\n\nLet's look at a 2D example as well:\n\nusing NMRInversions, GLMakie\n\npaths = [\".../NMRInversions.jl/example_data/spinsolve_IRCPMG/T1IRT2.dat\",\n         \".../NMRInversions.jl/example_data/spinsolve_IRCPMG/aqcu.par\"]\ndata = import_spinsolve(paths)\nresults = invert(data)\nplot(results)\n\n(Image: Resulting plot)\n\nSimilarly, now we can select regions by left-clicking at points within  the plot which enclose a region of interest. Then, we can :\n\nLabel current selection will highlight the selected polygon  with a dashed line and add some text in the plot with the weighed  average T_1T_2 of that region, as well as the volume fraction of it.\nFilter-out selection will remove everything inside the selection polygon.\nCancel current selection will discard the current polygon in   case you do not like what you selected.\nReset selection will remove all the selections you made.\nReset filter will undo anything you filtered-out.\nSave and exit will bring up a window so that you can save your   plot as a .png (without the buttons).\n\nThere are also some options to change the appearance of the plot, in  terms of colormap, contour levels and toggling between filled and non-filled contours. You can also add a title to the plot, which will be saved.\n\nIf you have multiple results, you can pass them as a matrix or vector  into the plot() function as:\n\nplot([results  results ; results results])\n\n(Image: Resulting plot)\n\nOf course, it would be more interesting if it wasn't four copies of the same results, but you get the point.","category":"section"},{"location":"tutorial/#Using-the-expfit-function","page":"Tutorial","title":"Using the expfit function","text":"In a similar way, we can perform various exponential  fits with the imported data using the expfit function.\n\nusing NMRInversions, GLMakie\n\npath = \".../NMRInversions.jl/example_data/csv_files/Chesire_sandstone_IR.csv\"\ndata = import_csv(IR, path)\n\na = expfit(1, data)  # mono-exponential fit\nb = expfit(2, data)  # bi-exponential fit\n\nplot(a,b)  # Visualize both on the same plot\n\n(Image: Resulting plot)\n\nOf course, these fits are not very good, that's why we'd use inversions  instead.","category":"section"}]
}
