<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · NMRInversions.jl</title><meta name="title" content="Functions · NMRInversions.jl"/><meta property="og:title" content="Functions · NMRInversions.jl"/><meta property="twitter:title" content="Functions · NMRInversions.jl"/><meta name="description" content="Documentation for NMRInversions.jl."/><meta property="og:description" content="Documentation for NMRInversions.jl."/><meta property="twitter:description" content="Documentation for NMRInversions.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="NMRInversions.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">NMRInversions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../theory/">Theory</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Importing-data"><span>Importing data</span></a></li><li><a class="tocitem" href="#Inversion"><span>Inversion</span></a></li><li><a class="tocitem" href="#Finding-alpha"><span>Finding alpha</span></a></li><li><a class="tocitem" href="#Exponential-fits"><span>Exponential fits</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li></ul></li><li><a class="tocitem" href="../types_structs/">Types and Structures</a></li><li><a class="tocitem" href="../savefiles/">Saving data</a></li><li><a class="tocitem" href="../references/">References</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aris-mav/NMRInversions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aris-mav/NMRInversions.jl/blob/master/docs/src/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>This page contains the documentation for various useful  functions in the NMRInversions package.</p><div class="admonition is-success" id="Tip-5a9012984a8bdfff"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-5a9012984a8bdfff" title="Permalink"></a></header><div class="admonition-body"><p>From the Julia command line, you can enter &#39;?&#39;,  followed by the name of any function, struct,  or object you want to learn more about (try it!). After typing <code>using NMRInversions</code> in the Julia console,  this feature will work for all the functions mentioned below.</p></div></div><div class="admonition is-info" id="Info-3e40660895d791bb"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-3e40660895d791bb" title="Permalink"></a></header><div class="admonition-body"><p>In Julia, function definitions look like this:</p><pre><code class="nohighlight hljs">foo(x, y, z ; a, b)</code></pre><p>For the example above, <code>foo</code> is the name of the function,  and the contents of the parenteses are the arguments.   Within the parenteses, we got two types of arguments:</p><ul><li>Positional arguments</li></ul><p>Everything that appears before the semicolon <code>;</code>  (x,y and z in this example) is necessary, and must be given in a specific order.</p><ul><li>Keyword arguments.</li></ul><p>Everything that appears after the semicolon <code>;</code>  (b and a in this example) is optional, and can be given in any order, but its name must be specified.</p><p>In the example above, we can call the function by typing <code>foo(1, 2, 3)</code>, (in which case, x=1, y=2, z=3, and the default value for <code>a</code> and <code>b</code> will be used).  You can also call the function by typing <code>foo(1, 2, 3, a=3)</code>, to specify the value for <code>a</code>,  or by typing <code>foo(1, 2, 3, b=3, a = 2)</code>, to specify the value for both <code>a</code> and <code>b</code>.</p><p>Sometimes, if there are many keyword arguments, we write  the function as foo(x, y ; kwargs...).  For the necessary arguments before the semicolon, order matters.  For the keyword arguments after the semicolon, order does not matter,  but the name of each argument must be specified. For more information, please refer to <a href="https://docs.julialang.org/en/v1/manual/functions/">this link</a>.</p></div></div><h2 id="Importing-data"><a class="docs-heading-anchor" href="#Importing-data">Importing data</a><a id="Importing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Importing-data" title="Permalink"></a></h2><p>This package offers some functions to import NMR experiment data of various formats. Alternatively, you can of course import your data however you see fit. If a format you&#39;re working with is not yet supported,  please <a href="https://github.com/arismavridis/NMRInversions.jl/issues/new">submit an issue</a>  and we&#39;ll work on it.</p><p>The most basic use case would be using data saved in a csv format,  where there are <em>only</em> two columns,  one for your x-axis (time for relaxation and b-factor for diffusion) and one for your y-axis (signal intensity).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.import_csv-Tuple{Type{&lt;:pulse_sequence1D}, String}" href="#NMRInversions.import_csv-Tuple{Type{&lt;:pulse_sequence1D}, String}"><code>NMRInversions.import_csv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">import_csv(seq, file)</code></pre><p>Import data from a CSV file. The function reads the file and returns an <code>input1D</code> structure.</p><ul><li><code>seq</code> is the 1D pulse sequence (e.g. IR, CPMG, PFG)</li><li><code>file</code> is the path to the CSV file which contains the data (x, y) in two respective columns.</li></ul><p>The function can be called without the seq argument, and the output will be the x and y vectors  (use it like, <code>x,y =import_csv()</code>). Alternatively, the function can also be called with only the seq argument, in which case a file dialog will open to select the file (use it like, <code>data = import_csv(IR)</code>)</p><p>Please note that this function will just import the data as is, without any unit conversions. Ensure that your x-axis is in SI.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/inversions_io.jl#L2-L20">source</a></section></article><p>If you&#39;re using a spinsolve instrument, you can use the <code>import_spinsolve</code> function. This one requires two files as an input.  The <code>aqcu.par</code> is automatically exported by SpinsolveExpert,  but you might have to export your data file manually in a csv format.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.import_spinsolve-Tuple{String}" href="#NMRInversions.import_spinsolve-Tuple{String}"><code>NMRInversions.import_spinsolve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">import_spinsolve(files)</code></pre><p>Import data from a Spinsolve experiment.  Two paths must be provided as follows (order is not important):</p><ul><li><code>files</code> = [.../datafile.csv , .../acqu.par] </li></ul><p>Calling this function without an argument by typing <code>import_spinsolve()</code> will open a file dialog to select the files. The function reads the acqu.par.bak file to get the acquisition parameters, and the .dat file to get the data.  The function returns an <code>input2D</code> structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/inversions_io.jl#L60-L68">source</a></section></article><p>For geospec instruments, you can export your raw data as a text file. That text file can be read by the <code>import_geospec</code> function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.import_geospec-Tuple{String}" href="#NMRInversions.import_geospec-Tuple{String}"><code>NMRInversions.import_geospec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">import_geospec(dir)</code></pre><p>Import data from a .txt format, as exported by Geospec instruments.</p><p>The function reads the relevant information, performs a phase correction on the data, and returns an <code>input1D</code> or <code>input2D</code> structure.</p><p>Calling this function without an argument by typing <code>import_geospec()</code>  will open a file dialog to select the .txt file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/inversions_io.jl#L181-L190">source</a></section></article><h2 id="Inversion"><a class="docs-heading-anchor" href="#Inversion">Inversion</a><a id="Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Inversion" title="Permalink"></a></h2><p>The most important function is <code>invert()</code>, which is the main function of the package. It works as follows:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.invert-Tuple{Type{&lt;:pulse_sequence1D}, AbstractArray, Vector}" href="#NMRInversions.invert-Tuple{Type{&lt;:pulse_sequence1D}, AbstractArray, Vector}"><code>NMRInversions.invert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Inversion for 1D pulse sequences:</strong></p><pre><code class="nohighlight hljs">invert(seq, x, y ; lims, alpha, solver, normalize)</code></pre><p>This function will build a kernel and use it to perform an inversion using the algorithm of your choice. The output is an <code>inv_out_1D</code> structure.</p><p>Necessary (positional) arguments:</p><ul><li><code>seq</code> is the 1D pulse sequence (e.g. IR, CPMG, PFG)</li><li><code>x</code> is the experiment x axis (time or b factor etc.)</li><li><code>y</code> is the experiment y axis (intensity of the NMR signal)</li></ul><p>Optional (keyword) arguments:</p><ul><li><code>lims=(a,b,c)</code> will set the &quot;limits&quot; of the output X, </li></ul><p>so that it starts from 10^a, ends in 10^b and consists of c  logarithmically spaced values. Alternatively, a vector of values can be used directly, if more freedom is needed  (e.g. <code>lims=exp10.(range(-4, 1, 128))</code>). By default, 128 points are used, logarithmically spaced between the first value  in x divided by 7, and the final value in x multiplied by 7.</p><ul><li><code>alpha</code> determines the smoothing term. Use a real number for a fixed alpha.  </li></ul><p>No selection will lead to automatically determining alpha through the  default method, which is <code>gcv()</code>.</p><ul><li><code>solver</code> is the algorithm used to do the inversion math. Default is <code>brd</code>.</li><li><code>normalize</code> will normalize <code>y</code> to 1 at the max value of <code>y</code>. Default is <code>true</code>.  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/inversion_functions.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.invert-Tuple{input1D}" href="#NMRInversions.invert-Tuple{input1D}"><code>NMRInversions.invert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">invert(data::input1D ; kwargs...)</code></pre><p>Instead of the positional arguments <code>seq</code>, <code>x</code> and <code>y</code>, you can use a single <code>input1D</code> structure, which contains the same information.  Especially useful if you&#39;re using the output of one  of the import functions (look documentation tutorial section).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/inversion_functions.jl#L87-L94">source</a></section></article><p>Due to Julia&#39;s multiple dispatch,  it is possible to define a function with the same name but different arguments, to achieve different results.</p><p>Because of that, the inversion function also works for 2D inversions, if the following arguments are used instead:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.invert-Tuple{Type{&lt;:pulse_sequence2D}, AbstractVector, AbstractVector, AbstractMatrix}" href="#NMRInversions.invert-Tuple{Type{&lt;:pulse_sequence2D}, AbstractVector, AbstractVector, AbstractMatrix}"><code>NMRInversions.invert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Inversion for 2D pulse sequences:</strong></p><pre><code class="nohighlight hljs">invert(seq, x_direct, x_indirect, Data; lims1, lims2, alpha, solver, normalize)</code></pre><p>This function will build a kernel and use it to perform an inversion using the algorithm of your choice. The output is an <code>inv_out_2D</code> structure.</p><p>Necessary (positional) arguments:</p><ul><li><code>seq</code> is the 2D pulse sequence (e.g. IRCPMG)</li><li><code>x_direct</code> is the direct dimension acquisition parameter (e.g. the times when you aquire CPMG echoes).</li><li><code>x_indirect</code> is the indirect dimension acquisition parameter (e.g. all the delay times τ in your IR sequence).</li><li><code>Data</code> is the 2D data matrix of complex data.</li></ul><p>Optional (keyword) arguments:</p><ul><li><code>lims1</code> determines the output &quot;range&quot; of the inversion in the direct dimension (e.g. T₂ times in IRCPMG)</li><li><code>lims2</code> determines the output &quot;range&quot; of the inversion in the indirect dimension (e.g. T₁ times in IRCPMG)</li></ul><p>In both cases above, you can use a tuple specifying the limits of the range,  or a vector of values, same as the <code>lims</code> argument in the 1D inversion function. By default, 64 points are used, logarithmically spaced between the first value  in x divided by 7, and the final value in x multiplied by 7 (for both direct and indirect x).</p><ul><li><code>alpha</code> determines the smoothing term. Use a real number for a fixed alpha.  No selection will lead to automatically determining alpha through the default method, which is <code>gcv</code>.</li><li><code>solver</code> is the algorithm used to do the inversion math. Default is <code>brd</code>.</li><li><code>normalize</code> will normalize <code>Data</code> so that its maximum value is 1. Default is <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/inversion_functions.jl#L102-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.invert-Tuple{input2D}" href="#NMRInversions.invert-Tuple{input2D}"><code>NMRInversions.invert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">invert(data::input2D ; kwargs...)</code></pre><p>Instead of the positional arguments <code>seq</code>, <code>x_direct</code> , <code>x_indirect</code> and <code>Data</code>, you can use a single <code>input2D</code>  structure, which contains the same information.  Especially useful if you&#39;re using the output of one of the  import functions (look documentation tutorial section).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/inversion_functions.jl#L185-L193">source</a></section></article><h2 id="Finding-alpha"><a class="docs-heading-anchor" href="#Finding-alpha">Finding alpha</a><a id="Finding-alpha-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-alpha" title="Permalink"></a></h2><p>Here we provide two options for finding the optimal value for alpha,  namely Generalized Cross Validation (GCV) or L-curve.  Generally gcv seems slightly more reliable in NMR, but it&#39;s far from  perfect, so it&#39;s good to have alternatives and cross-check. The following methods can be used as inputs for the <code>alpha</code> argument in the <code>invert</code> function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.gcv-Tuple{}" href="#NMRInversions.gcv-Tuple{}"><code>NMRInversions.gcv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gcv()</code></pre><p>Constructor for the gcv method described in Mitchell 2012. No arguments required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/types.jl#L180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.gcv-Tuple{Real}" href="#NMRInversions.gcv-Tuple{Real}"><code>NMRInversions.gcv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gcv(start; kwargs...)</code></pre><p>Constructor for finding the optimal alpha value via gcv score box optimization, given a starting value.</p><p>Necessary (positional) arguments:</p><ul><li><code>start</code> is the starting alpha value. </li></ul><p>Choose something sensible, usually a value between 0.1 and 10 would work well.</p><p>Optional (keyword) arguments:</p><ul><li><code>algorithm</code> determines which method will be used by Optim.jl to solve the problem.</li></ul><p>Default is LBFGS(). Only first order optimizers can be chosen here.  For more details, refer to Optim.jl documentation.</p><ul><li><code>opts</code> an Optim.Options() structure which can provide some preferences to the solver.</li></ul><p>Please have a look <a href="https://julianlsolvers.github.io/Optim.jl/v1.10/user/config/">here</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/types.jl#L187-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.gcv-Tuple{Real, Real}" href="#NMRInversions.gcv-Tuple{Real, Real}"><code>NMRInversions.gcv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gcv(lower, upper ; kwargs...)</code></pre><p>Constructor for finding the optimal alpha value via gcv score univariate optimization, given some lower and upper bounds.</p><p>Necessary (positional) arguments:</p><ul><li><code>lower</code> is the lower bound, or lowest alpha value the algorighm will consider.</li><li><code>upper</code> is the upper bound, or highest alpha value the algorighm will consider.</li></ul><p>Optional (keyword) arguments:</p><ul><li><code>algorithm</code> determines which method will be used by Optim.jl to solve the problem.</li></ul><p>Default is <code>Brent()</code> and the only alternative is <code>GoldenSection()</code>, which is normally slower.</p><ul><li><code>abs_tol</code> determines what&#39;s the smallest change in alpha the algorithm should care about.</li></ul><p>Default is 1e-3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/types.jl#L207-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.lcurve-Tuple{Real, Real, Int64}" href="#NMRInversions.lcurve-Tuple{Real, Real, Int64}"><code>NMRInversions.lcurve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lcurve(lowest_value, highest_value, number_of_steps)</code></pre><p>Constructor for testing all L-curve curvatures between some bounds and  picking the optimal.</p><ul><li><code>lowest_value</code> is the lowest alpha value.</li><li><code>highest_value</code> is the highest alpha value.</li><li><code>number_of_steps</code> is the number of alpha values that will be tested.</li></ul><p>This is a very crude and rather slow method, mostly for demonstration purposes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/types.jl#L226-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.lcurve-Tuple{Real}" href="#NMRInversions.lcurve-Tuple{Real}"><code>NMRInversions.lcurve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lcurve(start; kwargs...)</code></pre><p>Constructor for finding the optimal alpha value via lcurve curvature box optimization, given a starting value.</p><p>Necessary (positional) arguments:</p><ul><li><code>start</code> is the starting alpha value. </li></ul><p>Choose something sensible, usually a value between 0.1 and 10 would work well.</p><p>Optional (keyword) arguments:</p><ul><li><code>algorithm</code> determines which method will be used by Optim.jl to solve the problem.</li></ul><p>Default is LBFGS(). Only first order optimizers can be chosen here.  For more details, refer to Optim.jl documentation.</p><ul><li><code>opts</code> an Optim.Options() structure which can provide some preferences to the solver.</li></ul><p>Please have a look <a href="https://julianlsolvers.github.io/Optim.jl/v1.10/user/config/">here</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/types.jl#L240-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.lcurve-Tuple{Real, Real}" href="#NMRInversions.lcurve-Tuple{Real, Real}"><code>NMRInversions.lcurve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lcurve(lower, upper ; kwargs...)</code></pre><p>Constructor for finding the optimal alpha value via lcurve curvature univariate optimization, given some lower and upper bounds.</p><p>Necessary (positional) arguments:</p><ul><li><code>lower</code> is the lower bound, or lowest alpha value the algorighm will consider.</li><li><code>upper</code> is the upper bound, or highest alpha value the algorighm will consider.</li></ul><p>Optional (keyword) arguments:</p><ul><li><code>algorithm</code> determines which method will be used by Optim.jl to solve the problem.</li></ul><p>Default is <code>Brent()</code> and the only alternative is <code>GoldenSection()</code>, which is normally slower.</p><ul><li><code>abs_tol</code> determines what&#39;s the smallest change in alpha the algorithm should care about.</li></ul><p>Default is 1e-3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/types.jl#L259-L273">source</a></section></article><p>The <code>gcv()</code> method [<a href="../references/#Mitchell2012">2</a>] usually involves the least amount of  function calls and it is thus much faster, thus used as the default option. If you want more precision, the univariate or box methods should be used instead. Note that <code>gcv()</code> will NOT work for <code>pdhgm()</code> solver, so you&#39;ll have to choose  an alternative explicitly when using that solver.</p><h2 id="Exponential-fits"><a class="docs-heading-anchor" href="#Exponential-fits">Exponential fits</a><a id="Exponential-fits-1"></a><a class="docs-heading-anchor-permalink" href="#Exponential-fits" title="Permalink"></a></h2><p>For 1D data, we can use the <code>expfit</code> function to perform multiexponential fits. We can use the function by specifying either the number of exponential components, or a vector which defines the starting points for the regression. See below:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.expfit-Tuple{Union{Int64, Vector{&lt;:Real}}, Type{&lt;:pulse_sequence1D}, Vector, Vector}" href="#NMRInversions.expfit-Tuple{Union{Int64, Vector{&lt;:Real}}, Type{&lt;:pulse_sequence1D}, Vector, Vector}"><code>NMRInversions.expfit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expfit(n, seq, x, y; kwargs...)</code></pre><p>Fit an n-exponential function to the data <code>x</code> and <code>y</code>. </p><p>The outut is an <code>expfit_struct</code> structure.</p><p>Arguments:</p><ul><li><code>n</code> : Integer specifying the number of exponential terms.</li><li><code>seq</code> : pulse sequence.</li><li><code>x</code> : acquisition x parameter (time for relaxation or b-factor for diffusion).</li><li><code>y</code> : acquisition y parameter (magnetization).</li></ul><p>Optional arguments:</p><ul><li><code>solver</code> : Optim solver, default choice is IPNewton().</li><li><code>normalize</code> : Normalize the data before fitting? (default is true).</li><li><code>L</code> : An integer specifying which norm of the residuals you want to minimize (default is 2).</li></ul><p>The <code>n</code> argument can also be a vector of initial parameter guesses,  in which case it also determines the number of exponential terms used. It should be of the form [a1, b1, a2, b2, ...],  where a&#39;s are the amplitudes and b&#39;s are the parameters inside the exponentials.</p><p>The length of the vector in this case must be an even number.</p><p>The following examples might help to clarify: </p><p><code>expfit([a,b] , CPMG, x, y)</code> -&gt; mono-exponential fit with initial guess: a * exp.( (1/b) * x) </p><p><code>expfit([a,b,c,d] , CPMG, x, y)</code> -&gt; bi-exponential fit with initial guess: a * exp.( (1/b) * x) + c * exp.((1/d) * x) </p><p><code>expfit([a,b,c,d,e,f] , CPMG, x, y)</code> -&gt; tri-exponential fit with initial guess: a * exp.( (1/b) * x) + c * exp.((1/d) * x) + e * exp.((1/f) * x) </p><p>(where a,b,c,d,e,f are numbers of your choice)</p><p>Numbers of parameters beyond tri-exponential can also be used, but it is not recommended.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/exp_fits.jl#L49-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.expfit-Tuple{Union{Int64, Vector{&lt;:Real}}, input1D}" href="#NMRInversions.expfit-Tuple{Union{Int64, Vector{&lt;:Real}}, input1D}"><code>NMRInversions.expfit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expfit(n, data; kwargs...)</code></pre><p>Similar to the <code>invert</code> function, <code>expfit</code> can be called using an <code>input1D</code> structure.</p><p>Arguments:</p><ul><li><code>n</code> : Integer specifying the number of exponential terms.</li><li><code>data</code> : <code>input1D</code> structure containing the data to be fitted.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/exp_fits.jl#L164-L173">source</a></section></article><p>If you have some rough clue about what results you expect,  it&#39;s best to define some starting points close to these. (especially important if you&#39;re using double or tri-exponential fits.)</p><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>This package offers plotting capabilities, using its GLMakie extension. Simply use <code>using GLMakie</code> before or after <code>using NMRInversions</code> to load the package, and these functions become available.</p><p>We basically take the <code>plot()</code> function offered by GLMakie and extend it to types from the package.</p><p>For inversions results, if your <code>inv_out_1D</code> or <code>inv_out_2D</code> struct is saved as a variable named <code>r</code>, using <code>plot(r)</code> will run a GUI to interractively visualize your data and select regions to characterize.</p><p>Using a matrix or vector of results (e.g. plot([r1, r2, r3]) will plot all of them on the same figure, but without the selection options.</p><p>For example, for 1D inversions, we have:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Makie.plot-Tuple{inv_out_1D}" href="#Makie.plot-Tuple{inv_out_1D}"><code>Makie.plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(res::inv_out_1D)</code></pre><p>Run the GUI to plot the 1D inversion results and select peaks you want to label.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/ext/gui_1D.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Makie.plot-Tuple{VecOrMat{inv_out_1D}}" href="#Makie.plot-Tuple{VecOrMat{inv_out_1D}}"><code>Makie.plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(res_mat::VecOrMat{inv_out_1D};kwargs...)</code></pre><p>Plot the results contained in a vector of <code>inv_out_1D</code> structures.</p><p>The keyword (optional) arguments are:</p><ul><li><code>selections</code> : Whether to highlight the selections in the plots (default is <code>false</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/ext/gui_1D.jl#L3-L12">source</a></section></article><p>And for 2D inversions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Makie.plot-Tuple{inv_out_2D}" href="#Makie.plot-Tuple{inv_out_2D}"><code>Makie.plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Makie.plot(res::inv_out_2D)</code></pre><p>Run the GUI to plot the results and select peaks you want to label.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/ext/gui_2D.jl#L290-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Makie.plot-Tuple{AbstractVecOrMat{inv_out_2D}}" href="#Makie.plot-Tuple{AbstractVecOrMat{inv_out_2D}}"><code>Makie.plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(results::AbstractVecOrMat{inv_out_2D}; kwargs...)</code></pre><p>Plot the results contained in a matrix of <code>inv_out_2D</code> structures. The arrangement is determined by the shape of the matrix.</p><p>The arguments are:</p><ul><li><code>results</code> : The <code>inv_out_2D</code> matrix or vector containing the fit results.</li></ul><p>Keyword (optional) arguments:</p><ul><li><code>dims</code> : Dimensions of each plot (default: <code>(400, 400)</code>).</li><li><code>title</code> : Title of the plot (default: <code>&quot;&quot;</code>).</li><li><code>colormap</code> : Color map of the plot (default: <code>:viridis</code>).</li><li><code>contf</code> : Whether to use a filled contour plot (default : <code>false</code>).</li><li><code>levels</code> : Number of contour levels (default: <code>40</code>).</li><li><code>labelsizes</code> : Size of the axis labels (default: <code>(23, 23)</code>).</li><li><code>ticksizes</code> : Size of the axis ticks (default: <code>(14, 14)</code>).</li><li><code>titlesize</code> : Size of the title (default: <code>17</code>).</li><li><code>titlefont</code> : Font of the title (default: <code>:bold</code>).</li><li><code>legendlabelsize</code> : Size of the legend label (default: <code>12</code>)</li><li><code>gap</code> : The gap between the contour plot and the distribution plots (default: <code>0</code>)</li><li><code>extend_grid</code> : Whether to extend the gridlines to the plots on the sides (default: <code>false</code>)</li><li><code>legendposition</code> : Where to put the legend (default: <code>:lt</code> )</li><li><code>bandplots</code> : Whether to use band plots to highlight the selections in the top and right distributions (default: <code>true</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/ext/gui_2D.jl#L5-L30">source</a></section></article><p>For expfits, we have:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Makie.plot-Tuple{expfit_struct}" href="#Makie.plot-Tuple{expfit_struct}"><code>Makie.plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(res::expfit_struct...; kwargs...)</code></pre><p>Plot the results of an <code>expfit</code> call. </p><p>This function can take any number of <code>expfit_struct</code> structures as input. </p><p>e.g. <code>plot(data1)</code> plots the data and the corresponding fit, but <code>plot(data1, data2)</code> or <code>plot(data1, data2, data3)</code> work as well, and they plot all of the results on the same plot.</p><p>Keyword (optional) arguments:</p><ul><li><code>markersize</code> : The size of the markers (default is 7).</li><li><code>normeq</code> : Whether to plot the normalised form of the equation or not (default is <code>true</code>).</li><li><code>yscale</code> : The scale of the y-axis (default is <code>identity</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/ext/gui_expfits.jl#L2-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Makie.plot!-Tuple{Union{GridPosition, Figure}, expfit_struct}" href="#Makie.plot!-Tuple{Union{GridPosition, Figure}, expfit_struct}"><code>Makie.plot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot!(fig, res...; names, markersize, normeq)</code></pre><p>Plots the results of an <code>expfit</code> call on a figure or a grid position object.</p><p>The arguments are:</p><ul><li><code>fig</code> : The figure or grid position object.</li><li><code>res</code> : One or more <code>expfit_struct</code> structures containing the fit results.</li></ul><p>Keyword (optional) arguments:</p><ul><li><code>markersize</code> : The size of the markers (default is 7).</li><li><code>normeq</code> : Whether to plot the normalised form of the equation or not (default is <code>true</code>).</li><li><code>yscale</code> : The scale of the y-axis (default is <code>identity</code>).</li></ul><p>Note that the res inputs are not a vector, but individual <code>expfit_struct</code> structures, like: plot!(fig, data1, data2, data3). If you want to use a vector of <code>expfit_struct</code> structures, make sure to  splat it by using <code>...</code> in the function call (e.g. <code>plot!(fig, [data1, data2, data3]...)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/ext/gui_expfits.jl#L35-L54">source</a></section></article><h2 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h2><p>Once you have selected some peaks in your inversion results through the GUI, you might want to extract the weighted averages of these selected peaks, to get the underlying relaxation times or diffusion coefficients. The following functions do the job:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.weighted_averages-Tuple{inv_out_1D}" href="#NMRInversions.weighted_averages-Tuple{inv_out_1D}"><code>NMRInversions.weighted_averages</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weighted_averages(r::inv_out_1D)</code></pre><p>Return a vector with the weighted averages for  the selections in the input structure, and a  vector with the respective area fractions of  these selections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/misc.jl#L201-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.weighted_averages-Tuple{inv_out_2D}" href="#NMRInversions.weighted_averages-Tuple{inv_out_2D}"><code>NMRInversions.weighted_averages</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weighted_averages(r::inv_out_2D)</code></pre><p>Return two vectors with the weighted averages  for the selections in the input structure, one for each dimension, as well as a vector with the volume fractions of these selections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aris-mav/NMRInversions.jl/blob/ca42659ce7c2e4dc3657930de7558a382df1ac13/src/misc.jl#L240-L245">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../types_structs/">Types and Structures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 4 September 2025 13:49">Thursday 4 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
